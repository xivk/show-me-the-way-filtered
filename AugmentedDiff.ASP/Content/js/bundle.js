(function e(t, n, r) { function s(o, u) { if (!n[o]) { if (!t[o]) { var a = typeof require == "function" && require; if (!u && a) return a(o, !0); if (i) return i(o, !0); var f = new Error("Cannot find module '" + o + "'"); throw f.code = "MODULE_NOT_FOUND", f } var l = n[o] = { exports: {} }; t[o][0].call(l.exports, function (e) { var n = t[o][1][e]; return s(n ? n : e) }, l, l.exports, e, t, n, r) } return n[o].exports } var i = typeof require == "function" && require; for (var o = 0; o < r.length; o++) s(r[o]); return s })({
    1: [function (require, module, exports) {
        var osmStream = require('osm-stream'),
            reqwest = require('reqwest'),
            moment = require('moment'),
            _ = require('underscore');

        var bboxString = ["-90.0", "-180.0", "90.0", "180.0"];
        if (location.hash) {
            bboxString = location.hash.replace('#', '').split(',');
        }

        var ignore = ['bot-mode'];
        var BING_KEY = 'Arzdiw4nlOJzRwOz__qailc8NiR31Tt51dN2D7cm57NrnceZnCpgOkmJhNpGoppU';

        var map = L.map('map', {
            zoomControl: false,
            dragging: false,
            scrollWheelZoom: false,
            doubleClickZoom: false,
            boxZoom: false
        }).setView([51.505, -0.09], 13);

        var overview_map = L.map('overview_map', {
            zoomControl: false,
            dragging: false,
            touchZoom: false,
            scrollWheelZoom: false,
            doubleClickZoom: false,
            boxZoom: false
        }).setView([51.505, -0.09], 1);

        var bing = new L.BingLayer(BING_KEY, 'Aerial').addTo(map);

        var osm = new L.TileLayer('//a.tiles.mapbox.com/v3/saman.map-f8nluy8d/{z}/{x}/{y}.jpg70', {
            minZoom: 4,
            maxZoom: 8,
            attribution: '<a href="http://mapbox.com/about/maps/">Terms &amp; Conditions</a>'
        }).addTo(overview_map);

        var lineGroup = L.featureGroup().addTo(map);

        var changeset_info = document.getElementById('changeset_info');
        var changeset_tmpl = _.template(document.getElementById('changeset-template').innerHTML);
        var queue = [];

        // Remove Leaflet shoutouts
        map.attributionControl.setPrefix('');
        overview_map.attributionControl.setPrefix('');

        var bbox = new L.LatLngBounds(
                new L.LatLng(+bboxString[0], +bboxString[1]),
                new L.LatLng(+bboxString[2], +bboxString[3]));

        changeset_info.innerHTML = '<div class="loading">loading...</div>';

        var lastLocation = L.latLng(0, 0);

        function farFromLast(c) {
            try {
                return lastLocation.distanceTo(c) > 1000;
            } finally {
                lastLocation = c;
            }
        }

        function showLocation(ll) {
            var nominatim_tmpl = '//nominatim.openstreetmap.org/reverse?format=json' +
                '&lat={lat}&lon={lon}&zoom=5';
            reqwest({
                url: nominatim_tmpl.replace('{lat}', ll.lat).replace('{lon}', ll.lng),
                crossOrigin: true,
                type: 'json'
            }, function (resp) {
                document.getElementById('reverse-location').innerHTML =
                    '' + resp.display_name + '';
            });
        }

        function showComment(id) {
            var changeset_url_tmpl = '//www.openstreetmap.org/api/0.6/changeset/{id}';
            reqwest({
                url: changeset_url_tmpl
                    .replace('{id}', id),
                crossOrigin: true,
                type: 'xml'
            }, function (resp) {
                var tags = resp.getElementsByTagName('tag');
                var comment = '',
                    editor = '';
                for (var i = 0; i < tags.length; i++) {
                    if (tags[i].getAttribute('k') == 'comment') {
                        comment = tags[i].getAttribute('v').substring(0, 60);
                    }
                    if (tags[i].getAttribute('k') == 'created_by') {
                        editor = tags[i].getAttribute('v').substring(0, 50);
                    }
                }
                document.getElementById('comment').innerHTML = comment + ' in ' + editor;
            });
        }

        var runSpeed = 2000;

        // The number of changes to show per minute
        osmStream.runFn(function (err, data) {
            queue = _.filter(data, function (f) {
                if (f.feature && f.feature.type === 'way') {
                    return (bbox.intersects(new L.LatLngBounds(
                            new L.LatLng(f.feature.bounds[0], f.feature.bounds[1]),
                            new L.LatLng(f.feature.bounds[2], f.feature.bounds[3])))) &&
                        f.feature.linestring &&
                        ignore.indexOf(f.meta.user) === -1 &&
                        f.feature.linestring.length > 4;
                }
                return false;
            }).sort(function (a, b) {
                return (+new Date(a.meta.tilestamp)) -
                    (+new Date(a.meta.tilestamp));
            });
            // if (queue.length > 2000) queue = queue.slice(0, 2000);
            runSpeed = 1500;
        });

        function doDrawWay() {
            document.getElementById('queuesize').innerHTML = queue.length;
            if (queue.length) {
                drawWay(queue.pop(), function () {
                    doDrawWay();
                });
            } else {
                window.setTimeout(doDrawWay, runSpeed);
            }
        }

        function pruneLines() {
            var mb = map.getBounds();
            lineGroup.eachLayer(function (l) {
                if (!mb.intersects(l.getBounds())) {
                    lineGroup.removeLayer(l);
                } else {
                    l.setStyle({ opacity: 0.5 });
                }
            });
        }

        function setTagText(change) {
            var showTags = ['building', 'natural', 'leisure', 'waterway',
                'barrier', 'landuse', 'highway', 'power'];
            for (var i = 0; i < showTags.length; i++) {
                if (change.feature.tags[showTags[i]]) {
                    change.tagtext = showTags[i] + '=' + change.feature.tags[showTags[i]];
                    return change;
                }
            }
            change.tagtext = 'a way';
            return change;
        }

        function drawWay(change, cb) {
            pruneLines();

            var way = change.feature;

            // Zoom to the area in question
            var bounds = new L.LatLngBounds(
                new L.LatLng(way.bounds[2], way.bounds[3]),
                new L.LatLng(way.bounds[0], way.bounds[1]));

            if (farFromLast(bounds.getCenter())) showLocation(bounds.getCenter());
            showComment(way.changeset);

            var timedate = moment(change.meta.timestamp);
            change.timetext = timedate.fromNow();

            map.fitBounds(bounds);
            overview_map.panTo(bounds.getCenter());
            changeset_info.innerHTML = changeset_tmpl({ change: setTagText(change) });

            var color = { 'create': '#B7FF00', 'modify': '#FF00EA', 'delete': '#FF0000' }[change.type];
            if (change.feature.tags.building || change.feature.tags.area) {
                newLine = L.polygon([], {
                    opacity: 1,
                    color: color,
                    fill: color
                }).addTo(lineGroup);
            } else {
                newLine = L.polyline([], {
                    opacity: 1,
                    color: color
                }).addTo(lineGroup);
            }
            // This is a bit lower than 3000 because we want the whole way
            // to stay on the screen for a bit before moving on.
            var perPt = runSpeed / way.linestring.length;

            function drawPt(pt) {
                newLine.addLatLng(pt);
                if (way.linestring.length) {
                    window.setTimeout(function () {
                        drawPt(way.linestring.pop());
                    }, perPt);
                } else {
                    window.setTimeout(cb, perPt * 2);
                }
            }

            newLine.addLatLng(way.linestring.pop());
            drawPt(way.linestring.pop());
        }

        doDrawWay();

    }, { "moment": 2, "osm-stream": 3, "reqwest": 6, "underscore": 7 }], 2: [function (require, module, exports) {
        // moment.js
        // version : 2.0.0
        // author : Tim Wood
        // license : MIT
        // momentjs.com

        (function (undefined) {

            /************************************
                Constants
            ************************************/

            var moment,
                VERSION = "2.0.0",
                round = Math.round, i,
                // internal storage for language config files
                languages = {},

                // check for nodeJS
                hasModule = (typeof module !== 'undefined' && module.exports),

                // ASP.NET json date format regex
                aspNetJsonRegex = /^\/?Date\((\-?\d+)/i,

                // format tokens
                formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|YYYYY|YYYY|YY|a|A|hh?|HH?|mm?|ss?|SS?S?|X|zz?|ZZ?|.)/g,
                localFormattingTokens = /(\[[^\[]*\])|(\\)?(LT|LL?L?L?|l{1,4})/g,

                // parsing tokens
                parseMultipleFormatChunker = /([0-9a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+)/gi,

                // parsing token regexes
                parseTokenOneOrTwoDigits = /\d\d?/, // 0 - 99
                parseTokenOneToThreeDigits = /\d{1,3}/, // 0 - 999
                parseTokenThreeDigits = /\d{3}/, // 000 - 999
                parseTokenFourDigits = /\d{1,4}/, // 0 - 9999
                parseTokenSixDigits = /[+\-]?\d{1,6}/, // -999,999 - 999,999
                parseTokenWord = /[0-9]*[a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF]+\s*?[\u0600-\u06FF]+/i, // any word (or two) characters or numbers including two word month in arabic.
                parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/i, // +00:00 -00:00 +0000 -0000 or Z
                parseTokenT = /T/i, // T (ISO seperator)
                parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123

                // preliminary iso regex
                // 0000-00-00 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000
                isoRegex = /^\s*\d{4}-\d\d-\d\d((T| )(\d\d(:\d\d(:\d\d(\.\d\d?\d?)?)?)?)?([\+\-]\d\d:?\d\d)?)?/,
                isoFormat = 'YYYY-MM-DDTHH:mm:ssZ',

                // iso time formats and regexes
                isoTimes = [
                    ['HH:mm:ss.S', /(T| )\d\d:\d\d:\d\d\.\d{1,3}/],
                    ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],
                    ['HH:mm', /(T| )\d\d:\d\d/],
                    ['HH', /(T| )\d\d/]
                ],

                // timezone chunker "+10:00" > ["10", "00"] or "-1530" > ["-15", "30"]
                parseTimezoneChunker = /([\+\-]|\d\d)/gi,

                // getter and setter names
                proxyGettersAndSetters = 'Month|Date|Hours|Minutes|Seconds|Milliseconds'.split('|'),
                unitMillisecondFactors = {
                    'Milliseconds': 1,
                    'Seconds': 1e3,
                    'Minutes': 6e4,
                    'Hours': 36e5,
                    'Days': 864e5,
                    'Months': 2592e6,
                    'Years': 31536e6
                },

                // format function strings
                formatFunctions = {},

                // tokens to ordinalize and pad
                ordinalizeTokens = 'DDD w W M D d'.split(' '),
                paddedTokens = 'M D H h m s w W'.split(' '),

                formatTokenFunctions = {
                    M: function () {
                        return this.month() + 1;
                    },
                    MMM: function (format) {
                        return this.lang().monthsShort(this, format);
                    },
                    MMMM: function (format) {
                        return this.lang().months(this, format);
                    },
                    D: function () {
                        return this.date();
                    },
                    DDD: function () {
                        return this.dayOfYear();
                    },
                    d: function () {
                        return this.day();
                    },
                    dd: function (format) {
                        return this.lang().weekdaysMin(this, format);
                    },
                    ddd: function (format) {
                        return this.lang().weekdaysShort(this, format);
                    },
                    dddd: function (format) {
                        return this.lang().weekdays(this, format);
                    },
                    w: function () {
                        return this.week();
                    },
                    W: function () {
                        return this.isoWeek();
                    },
                    YY: function () {
                        return leftZeroFill(this.year() % 100, 2);
                    },
                    YYYY: function () {
                        return leftZeroFill(this.year(), 4);
                    },
                    YYYYY: function () {
                        return leftZeroFill(this.year(), 5);
                    },
                    a: function () {
                        return this.lang().meridiem(this.hours(), this.minutes(), true);
                    },
                    A: function () {
                        return this.lang().meridiem(this.hours(), this.minutes(), false);
                    },
                    H: function () {
                        return this.hours();
                    },
                    h: function () {
                        return this.hours() % 12 || 12;
                    },
                    m: function () {
                        return this.minutes();
                    },
                    s: function () {
                        return this.seconds();
                    },
                    S: function () {
                        return ~~(this.milliseconds() / 100);
                    },
                    SS: function () {
                        return leftZeroFill(~~(this.milliseconds() / 10), 2);
                    },
                    SSS: function () {
                        return leftZeroFill(this.milliseconds(), 3);
                    },
                    Z: function () {
                        var a = -this.zone(),
                            b = "+";
                        if (a < 0) {
                            a = -a;
                            b = "-";
                        }
                        return b + leftZeroFill(~~(a / 60), 2) + ":" + leftZeroFill(~~a % 60, 2);
                    },
                    ZZ: function () {
                        var a = -this.zone(),
                            b = "+";
                        if (a < 0) {
                            a = -a;
                            b = "-";
                        }
                        return b + leftZeroFill(~~(10 * a / 6), 4);
                    },
                    X: function () {
                        return this.unix();
                    }
                };

            function padToken(func, count) {
                return function (a) {
                    return leftZeroFill(func.call(this, a), count);
                };
            }
            function ordinalizeToken(func) {
                return function (a) {
                    return this.lang().ordinal(func.call(this, a));
                };
            }

            while (ordinalizeTokens.length) {
                i = ordinalizeTokens.pop();
                formatTokenFunctions[i + 'o'] = ordinalizeToken(formatTokenFunctions[i]);
            }
            while (paddedTokens.length) {
                i = paddedTokens.pop();
                formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2);
            }
            formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3);


            /************************************
                Constructors
            ************************************/

            function Language() {

            }

            // Moment prototype object
            function Moment(config) {
                extend(this, config);
            }

            // Duration Constructor
            function Duration(duration) {
                var data = this._data = {},
                    years = duration.years || duration.year || duration.y || 0,
                    months = duration.months || duration.month || duration.M || 0,
                    weeks = duration.weeks || duration.week || duration.w || 0,
                    days = duration.days || duration.day || duration.d || 0,
                    hours = duration.hours || duration.hour || duration.h || 0,
                    minutes = duration.minutes || duration.minute || duration.m || 0,
                    seconds = duration.seconds || duration.second || duration.s || 0,
                    milliseconds = duration.milliseconds || duration.millisecond || duration.ms || 0;

                // representation for dateAddRemove
                this._milliseconds = milliseconds +
                    seconds * 1e3 + // 1000
                    minutes * 6e4 + // 1000 * 60
                    hours * 36e5; // 1000 * 60 * 60
                // Because of dateAddRemove treats 24 hours as different from a
                // day when working around DST, we need to store them separately
                this._days = days +
                    weeks * 7;
                // It is impossible translate months into days without knowing
                // which months you are are talking about, so we have to store
                // it separately.
                this._months = months +
                    years * 12;

                // The following code bubbles up values, see the tests for
                // examples of what that means.
                data.milliseconds = milliseconds % 1000;
                seconds += absRound(milliseconds / 1000);

                data.seconds = seconds % 60;
                minutes += absRound(seconds / 60);

                data.minutes = minutes % 60;
                hours += absRound(minutes / 60);

                data.hours = hours % 24;
                days += absRound(hours / 24);

                days += weeks * 7;
                data.days = days % 30;

                months += absRound(days / 30);

                data.months = months % 12;
                years += absRound(months / 12);

                data.years = years;
            }


            /************************************
                Helpers
            ************************************/


            function extend(a, b) {
                for (var i in b) {
                    if (b.hasOwnProperty(i)) {
                        a[i] = b[i];
                    }
                }
                return a;
            }

            function absRound(number) {
                if (number < 0) {
                    return Math.ceil(number);
                } else {
                    return Math.floor(number);
                }
            }

            // left zero fill a number
            // see http://jsperf.com/left-zero-filling for performance comparison
            function leftZeroFill(number, targetLength) {
                var output = number + '';
                while (output.length < targetLength) {
                    output = '0' + output;
                }
                return output;
            }

            // helper function for _.addTime and _.subtractTime
            function addOrSubtractDurationFromMoment(mom, duration, isAdding) {
                var ms = duration._milliseconds,
                    d = duration._days,
                    M = duration._months,
                    currentDate;

                if (ms) {
                    mom._d.setTime(+mom + ms * isAdding);
                }
                if (d) {
                    mom.date(mom.date() + d * isAdding);
                }
                if (M) {
                    currentDate = mom.date();
                    mom.date(1)
                        .month(mom.month() + M * isAdding)
                        .date(Math.min(currentDate, mom.daysInMonth()));
                }
            }

            // check if is an array
            function isArray(input) {
                return Object.prototype.toString.call(input) === '[object Array]';
            }

            // compare two arrays, return the number of differences
            function compareArrays(array1, array2) {
                var len = Math.min(array1.length, array2.length),
                    lengthDiff = Math.abs(array1.length - array2.length),
                    diffs = 0,
                    i;
                for (i = 0; i < len; i++) {
                    if (~~array1[i] !== ~~array2[i]) {
                        diffs++;
                    }
                }
                return diffs + lengthDiff;
            }


            /************************************
                Languages
            ************************************/


            Language.prototype = {
                set: function (config) {
                    var prop, i;
                    for (i in config) {
                        prop = config[i];
                        if (typeof prop === 'function') {
                            this[i] = prop;
                        } else {
                            this['_' + i] = prop;
                        }
                    }
                },

                _months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
                months: function (m) {
                    return this._months[m.month()];
                },

                _monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
                monthsShort: function (m) {
                    return this._monthsShort[m.month()];
                },

                monthsParse: function (monthName) {
                    var i, mom, regex, output;

                    if (!this._monthsParse) {
                        this._monthsParse = [];
                    }

                    for (i = 0; i < 12; i++) {
                        // make the regex if we don't have it already
                        if (!this._monthsParse[i]) {
                            mom = moment([2000, i]);
                            regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                            this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
                        }
                        // test the regex
                        if (this._monthsParse[i].test(monthName)) {
                            return i;
                        }
                    }
                },

                _weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
                weekdays: function (m) {
                    return this._weekdays[m.day()];
                },

                _weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
                weekdaysShort: function (m) {
                    return this._weekdaysShort[m.day()];
                },

                _weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
                weekdaysMin: function (m) {
                    return this._weekdaysMin[m.day()];
                },

                _longDateFormat: {
                    LT: "h:mm A",
                    L: "MM/DD/YYYY",
                    LL: "MMMM D YYYY",
                    LLL: "MMMM D YYYY LT",
                    LLLL: "dddd, MMMM D YYYY LT"
                },
                longDateFormat: function (key) {
                    var output = this._longDateFormat[key];
                    if (!output && this._longDateFormat[key.toUpperCase()]) {
                        output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function (val) {
                            return val.slice(1);
                        });
                        this._longDateFormat[key] = output;
                    }
                    return output;
                },

                meridiem: function (hours, minutes, isLower) {
                    if (hours > 11) {
                        return isLower ? 'pm' : 'PM';
                    } else {
                        return isLower ? 'am' : 'AM';
                    }
                },

                _calendar: {
                    sameDay: '[Today at] LT',
                    nextDay: '[Tomorrow at] LT',
                    nextWeek: 'dddd [at] LT',
                    lastDay: '[Yesterday at] LT',
                    lastWeek: '[last] dddd [at] LT',
                    sameElse: 'L'
                },
                calendar: function (key, mom) {
                    var output = this._calendar[key];
                    return typeof output === 'function' ? output.apply(mom) : output;
                },

                _relativeTime: {
                    future: "in %s",
                    past: "%s ago",
                    s: "a few seconds",
                    m: "a minute",
                    mm: "%d minutes",
                    h: "an hour",
                    hh: "%d hours",
                    d: "a day",
                    dd: "%d days",
                    M: "a month",
                    MM: "%d months",
                    y: "a year",
                    yy: "%d years"
                },
                relativeTime: function (number, withoutSuffix, string, isFuture) {
                    var output = this._relativeTime[string];
                    return (typeof output === 'function') ?
                        output(number, withoutSuffix, string, isFuture) :
                        output.replace(/%d/i, number);
                },
                pastFuture: function (diff, output) {
                    var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
                    return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
                },

                ordinal: function (number) {
                    return this._ordinal.replace("%d", number);
                },
                _ordinal: "%d",

                preparse: function (string) {
                    return string;
                },

                postformat: function (string) {
                    return string;
                },

                week: function (mom) {
                    return weekOfYear(mom, this._week.dow, this._week.doy);
                },
                _week: {
                    dow: 0, // Sunday is the first day of the week.
                    doy: 6  // The week that contains Jan 1st is the first week of the year.
                }
            };

            // Loads a language definition into the `languages` cache.  The function
            // takes a key and optionally values.  If not in the browser and no values
            // are provided, it will load the language file module.  As a convenience,
            // this function also returns the language values.
            function loadLang(key, values) {
                values.abbr = key;
                if (!languages[key]) {
                    languages[key] = new Language();
                }
                languages[key].set(values);
                return languages[key];
            }

            // Determines which language definition to use and returns it.
            //
            // With no parameters, it will return the global language.  If you
            // pass in a language key, such as 'en', it will return the
            // definition for 'en', so long as 'en' has already been loaded using
            // moment.lang.
            function getLangDefinition(key) {
                if (!key) {
                    return moment.fn._lang;
                }
                if (!languages[key] && hasModule) {
                    require('./lang/' + key);
                }
                return languages[key];
            }


            /************************************
                Formatting
            ************************************/


            function removeFormattingTokens(input) {
                if (input.match(/\[.*\]/)) {
                    return input.replace(/^\[|\]$/g, "");
                }
                return input.replace(/\\/g, "");
            }

            function makeFormatFunction(format) {
                var array = format.match(formattingTokens), i, length;

                for (i = 0, length = array.length; i < length; i++) {
                    if (formatTokenFunctions[array[i]]) {
                        array[i] = formatTokenFunctions[array[i]];
                    } else {
                        array[i] = removeFormattingTokens(array[i]);
                    }
                }

                return function (mom) {
                    var output = "";
                    for (i = 0; i < length; i++) {
                        output += typeof array[i].call === 'function' ? array[i].call(mom, format) : array[i];
                    }
                    return output;
                };
            }

            // format date using native date object
            function formatMoment(m, format) {
                var i = 5;

                function replaceLongDateFormatTokens(input) {
                    return m.lang().longDateFormat(input) || input;
                }

                while (i-- && localFormattingTokens.test(format)) {
                    format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
                }

                if (!formatFunctions[format]) {
                    formatFunctions[format] = makeFormatFunction(format);
                }

                return formatFunctions[format](m);
            }


            /************************************
                Parsing
            ************************************/


            // get the regex to find the next token
            function getParseRegexForToken(token) {
                switch (token) {
                    case 'DDDD':
                        return parseTokenThreeDigits;
                    case 'YYYY':
                        return parseTokenFourDigits;
                    case 'YYYYY':
                        return parseTokenSixDigits;
                    case 'S':
                    case 'SS':
                    case 'SSS':
                    case 'DDD':
                        return parseTokenOneToThreeDigits;
                    case 'MMM':
                    case 'MMMM':
                    case 'dd':
                    case 'ddd':
                    case 'dddd':
                    case 'a':
                    case 'A':
                        return parseTokenWord;
                    case 'X':
                        return parseTokenTimestampMs;
                    case 'Z':
                    case 'ZZ':
                        return parseTokenTimezone;
                    case 'T':
                        return parseTokenT;
                    case 'MM':
                    case 'DD':
                    case 'YY':
                    case 'HH':
                    case 'hh':
                    case 'mm':
                    case 'ss':
                    case 'M':
                    case 'D':
                    case 'd':
                    case 'H':
                    case 'h':
                    case 'm':
                    case 's':
                        return parseTokenOneOrTwoDigits;
                    default:
                        return new RegExp(token.replace('\\', ''));
                }
            }

            // function to convert string input to date
            function addTimeToArrayFromToken(token, input, config) {
                var a, b,
                    datePartArray = config._a;

                switch (token) {
                    // MONTH
                    case 'M': // fall through to MM
                    case 'MM':
                        datePartArray[1] = (input == null) ? 0 : ~~input - 1;
                        break;
                    case 'MMM': // fall through to MMMM
                    case 'MMMM':
                        a = getLangDefinition(config._l).monthsParse(input);
                        // if we didn't find a month name, mark the date as invalid.
                        if (a != null) {
                            datePartArray[1] = a;
                        } else {
                            config._isValid = false;
                        }
                        break;
                        // DAY OF MONTH
                    case 'D': // fall through to DDDD
                    case 'DD': // fall through to DDDD
                    case 'DDD': // fall through to DDDD
                    case 'DDDD':
                        if (input != null) {
                            datePartArray[2] = ~~input;
                        }
                        break;
                        // YEAR
                    case 'YY':
                        datePartArray[0] = ~~input + (~~input > 68 ? 1900 : 2000);
                        break;
                    case 'YYYY':
                    case 'YYYYY':
                        datePartArray[0] = ~~input;
                        break;
                        // AM / PM
                    case 'a': // fall through to A
                    case 'A':
                        config._isPm = ((input + '').toLowerCase() === 'pm');
                        break;
                        // 24 HOUR
                    case 'H': // fall through to hh
                    case 'HH': // fall through to hh
                    case 'h': // fall through to hh
                    case 'hh':
                        datePartArray[3] = ~~input;
                        break;
                        // MINUTE
                    case 'm': // fall through to mm
                    case 'mm':
                        datePartArray[4] = ~~input;
                        break;
                        // SECOND
                    case 's': // fall through to ss
                    case 'ss':
                        datePartArray[5] = ~~input;
                        break;
                        // MILLISECOND
                    case 'S':
                    case 'SS':
                    case 'SSS':
                        datePartArray[6] = ~~(('0.' + input) * 1000);
                        break;
                        // UNIX TIMESTAMP WITH MS
                    case 'X':
                        config._d = new Date(parseFloat(input) * 1000);
                        break;
                        // TIMEZONE
                    case 'Z': // fall through to ZZ
                    case 'ZZ':
                        config._useUTC = true;
                        a = (input + '').match(parseTimezoneChunker);
                        if (a && a[1]) {
                            config._tzh = ~~a[1];
                        }
                        if (a && a[2]) {
                            config._tzm = ~~a[2];
                        }
                        // reverse offsets
                        if (a && a[0] === '+') {
                            config._tzh = -config._tzh;
                            config._tzm = -config._tzm;
                        }
                        break;
                }

                // if the input is null, the date is not valid
                if (input == null) {
                    config._isValid = false;
                }
            }

            // convert an array to a date.
            // the array should mirror the parameters below
            // note: all values past the year are optional and will default to the lowest possible value.
            // [year, month, day , hour, minute, second, millisecond]
            function dateFromArray(config) {
                var i, date, input = [];

                if (config._d) {
                    return;
                }

                for (i = 0; i < 7; i++) {
                    config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
                }

                // add the offsets to the time to be parsed so that we can have a clean array for checking isValid
                input[3] += config._tzh || 0;
                input[4] += config._tzm || 0;

                date = new Date(0);

                if (config._useUTC) {
                    date.setUTCFullYear(input[0], input[1], input[2]);
                    date.setUTCHours(input[3], input[4], input[5], input[6]);
                } else {
                    date.setFullYear(input[0], input[1], input[2]);
                    date.setHours(input[3], input[4], input[5], input[6]);
                }

                config._d = date;
            }

            // date from string and format string
            function makeDateFromStringAndFormat(config) {
                // This array is used to make a Date, either with `new Date` or `Date.UTC`
                var tokens = config._f.match(formattingTokens),
                    string = config._i,
                    i, parsedInput;

                config._a = [];

                for (i = 0; i < tokens.length; i++) {
                    parsedInput = (getParseRegexForToken(tokens[i]).exec(string) || [])[0];
                    if (parsedInput) {
                        string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                    }
                    // don't parse if its not a known token
                    if (formatTokenFunctions[tokens[i]]) {
                        addTimeToArrayFromToken(tokens[i], parsedInput, config);
                    }
                }
                // handle am pm
                if (config._isPm && config._a[3] < 12) {
                    config._a[3] += 12;
                }
                // if is 12 am, change hours to 0
                if (config._isPm === false && config._a[3] === 12) {
                    config._a[3] = 0;
                }
                // return
                dateFromArray(config);
            }

            // date from string and array of format strings
            function makeDateFromStringAndArray(config) {
                var tempConfig,
                    tempMoment,
                    bestMoment,

                    scoreToBeat = 99,
                    i,
                    currentDate,
                    currentScore;

                while (config._f.length) {
                    tempConfig = extend({}, config);
                    tempConfig._f = config._f.pop();
                    makeDateFromStringAndFormat(tempConfig);
                    tempMoment = new Moment(tempConfig);

                    if (tempMoment.isValid()) {
                        bestMoment = tempMoment;
                        break;
                    }

                    currentScore = compareArrays(tempConfig._a, tempMoment.toArray());

                    if (currentScore < scoreToBeat) {
                        scoreToBeat = currentScore;
                        bestMoment = tempMoment;
                    }
                }

                extend(config, bestMoment);
            }

            // date from iso format
            function makeDateFromString(config) {
                var i,
                    string = config._i;
                if (isoRegex.exec(string)) {
                    config._f = 'YYYY-MM-DDT';
                    for (i = 0; i < 4; i++) {
                        if (isoTimes[i][1].exec(string)) {
                            config._f += isoTimes[i][0];
                            break;
                        }
                    }
                    if (parseTokenTimezone.exec(string)) {
                        config._f += " Z";
                    }
                    makeDateFromStringAndFormat(config);
                } else {
                    config._d = new Date(string);
                }
            }

            function makeDateFromInput(config) {
                var input = config._i,
                    matched = aspNetJsonRegex.exec(input);

                if (input === undefined) {
                    config._d = new Date();
                } else if (matched) {
                    config._d = new Date(+matched[1]);
                } else if (typeof input === 'string') {
                    makeDateFromString(config);
                } else if (isArray(input)) {
                    config._a = input.slice(0);
                    dateFromArray(config);
                } else {
                    config._d = input instanceof Date ? new Date(+input) : new Date(input);
                }
            }


            /************************************
                Relative Time
            ************************************/


            // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
            function substituteTimeAgo(string, number, withoutSuffix, isFuture, lang) {
                return lang.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
            }

            function relativeTime(milliseconds, withoutSuffix, lang) {
                var seconds = round(Math.abs(milliseconds) / 1000),
                    minutes = round(seconds / 60),
                    hours = round(minutes / 60),
                    days = round(hours / 24),
                    years = round(days / 365),
                    args = seconds < 45 && ['s', seconds] ||
                        minutes === 1 && ['m'] ||
                        minutes < 45 && ['mm', minutes] ||
                        hours === 1 && ['h'] ||
                        hours < 22 && ['hh', hours] ||
                        days === 1 && ['d'] ||
                        days <= 25 && ['dd', days] ||
                        days <= 45 && ['M'] ||
                        days < 345 && ['MM', round(days / 30)] ||
                        years === 1 && ['y'] || ['yy', years];
                args[2] = withoutSuffix;
                args[3] = milliseconds > 0;
                args[4] = lang;
                return substituteTimeAgo.apply({}, args);
            }


            /************************************
                Week of Year
            ************************************/


            // firstDayOfWeek       0 = sun, 6 = sat
            //                      the day of the week that starts the week
            //                      (usually sunday or monday)
            // firstDayOfWeekOfYear 0 = sun, 6 = sat
            //                      the first week is the week that contains the first
            //                      of this day of the week
            //                      (eg. ISO weeks use thursday (4))
            function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
                var end = firstDayOfWeekOfYear - firstDayOfWeek,
                    daysToDayOfWeek = firstDayOfWeekOfYear - mom.day();


                if (daysToDayOfWeek > end) {
                    daysToDayOfWeek -= 7;
                }

                if (daysToDayOfWeek < end - 7) {
                    daysToDayOfWeek += 7;
                }

                return Math.ceil(moment(mom).add('d', daysToDayOfWeek).dayOfYear() / 7);
            }


            /************************************
                Top Level Functions
            ************************************/

            function makeMoment(config) {
                var input = config._i,
                    format = config._f;

                if (input === null || input === '') {
                    return null;
                }

                if (typeof input === 'string') {
                    config._i = input = getLangDefinition().preparse(input);
                }

                if (moment.isMoment(input)) {
                    config = extend({}, input);
                    config._d = new Date(+input._d);
                } else if (format) {
                    if (isArray(format)) {
                        makeDateFromStringAndArray(config);
                    } else {
                        makeDateFromStringAndFormat(config);
                    }
                } else {
                    makeDateFromInput(config);
                }

                return new Moment(config);
            }

            moment = function (input, format, lang) {
                return makeMoment({
                    _i: input,
                    _f: format,
                    _l: lang,
                    _isUTC: false
                });
            };

            // creating with utc
            moment.utc = function (input, format, lang) {
                return makeMoment({
                    _useUTC: true,
                    _isUTC: true,
                    _l: lang,
                    _i: input,
                    _f: format
                });
            };

            // creating with unix timestamp (in seconds)
            moment.unix = function (input) {
                return moment(input * 1000);
            };

            // duration
            moment.duration = function (input, key) {
                var isDuration = moment.isDuration(input),
                    isNumber = (typeof input === 'number'),
                    duration = (isDuration ? input._data : (isNumber ? {} : input)),
                    ret;

                if (isNumber) {
                    if (key) {
                        duration[key] = input;
                    } else {
                        duration.milliseconds = input;
                    }
                }

                ret = new Duration(duration);

                if (isDuration && input.hasOwnProperty('_lang')) {
                    ret._lang = input._lang;
                }

                return ret;
            };

            // version number
            moment.version = VERSION;

            // default format
            moment.defaultFormat = isoFormat;

            // This function will load languages and then set the global language.  If
            // no arguments are passed in, it will simply return the current global
            // language key.
            moment.lang = function (key, values) {
                var i;

                if (!key) {
                    return moment.fn._lang._abbr;
                }
                if (values) {
                    loadLang(key, values);
                } else if (!languages[key]) {
                    getLangDefinition(key);
                }
                moment.duration.fn._lang = moment.fn._lang = getLangDefinition(key);
            };

            // returns language data
            moment.langData = function (key) {
                if (key && key._lang && key._lang._abbr) {
                    key = key._lang._abbr;
                }
                return getLangDefinition(key);
            };

            // compare moment object
            moment.isMoment = function (obj) {
                return obj instanceof Moment;
            };

            // for typechecking Duration objects
            moment.isDuration = function (obj) {
                return obj instanceof Duration;
            };


            /************************************
                Moment Prototype
            ************************************/


            moment.fn = Moment.prototype = {

                clone: function () {
                    return moment(this);
                },

                valueOf: function () {
                    return +this._d;
                },

                unix: function () {
                    return Math.floor(+this._d / 1000);
                },

                toString: function () {
                    return this.format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
                },

                toDate: function () {
                    return this._d;
                },

                toJSON: function () {
                    return moment.utc(this).format('YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
                },

                toArray: function () {
                    var m = this;
                    return [
                        m.year(),
                        m.month(),
                        m.date(),
                        m.hours(),
                        m.minutes(),
                        m.seconds(),
                        m.milliseconds()
                    ];
                },

                isValid: function () {
                    if (this._isValid == null) {
                        if (this._a) {
                            this._isValid = !compareArrays(this._a, (this._isUTC ? moment.utc(this._a) : moment(this._a)).toArray());
                        } else {
                            this._isValid = !isNaN(this._d.getTime());
                        }
                    }
                    return !!this._isValid;
                },

                utc: function () {
                    this._isUTC = true;
                    return this;
                },

                local: function () {
                    this._isUTC = false;
                    return this;
                },

                format: function (inputString) {
                    var output = formatMoment(this, inputString || moment.defaultFormat);
                    return this.lang().postformat(output);
                },

                add: function (input, val) {
                    var dur;
                    // switch args to support add('s', 1) and add(1, 's')
                    if (typeof input === 'string') {
                        dur = moment.duration(+val, input);
                    } else {
                        dur = moment.duration(input, val);
                    }
                    addOrSubtractDurationFromMoment(this, dur, 1);
                    return this;
                },

                subtract: function (input, val) {
                    var dur;
                    // switch args to support subtract('s', 1) and subtract(1, 's')
                    if (typeof input === 'string') {
                        dur = moment.duration(+val, input);
                    } else {
                        dur = moment.duration(input, val);
                    }
                    addOrSubtractDurationFromMoment(this, dur, -1);
                    return this;
                },

                diff: function (input, units, asFloat) {
                    var that = this._isUTC ? moment(input).utc() : moment(input).local(),
                        zoneDiff = (this.zone() - that.zone()) * 6e4,
                        diff, output;

                    if (units) {
                        // standardize on singular form
                        units = units.replace(/s$/, '');
                    }

                    if (units === 'year' || units === 'month') {
                        diff = (this.daysInMonth() + that.daysInMonth()) * 432e5; // 24 * 60 * 60 * 1000 / 2
                        output = ((this.year() - that.year()) * 12) + (this.month() - that.month());
                        output += ((this - moment(this).startOf('month')) - (that - moment(that).startOf('month'))) / diff;
                        if (units === 'year') {
                            output = output / 12;
                        }
                    } else {
                        diff = (this - that) - zoneDiff;
                        output = units === 'second' ? diff / 1e3 : // 1000
                            units === 'minute' ? diff / 6e4 : // 1000 * 60
                            units === 'hour' ? diff / 36e5 : // 1000 * 60 * 60
                            units === 'day' ? diff / 864e5 : // 1000 * 60 * 60 * 24
                            units === 'week' ? diff / 6048e5 : // 1000 * 60 * 60 * 24 * 7
                            diff;
                    }
                    return asFloat ? output : absRound(output);
                },

                from: function (time, withoutSuffix) {
                    return moment.duration(this.diff(time)).lang(this.lang()._abbr).humanize(!withoutSuffix);
                },

                fromNow: function (withoutSuffix) {
                    return this.from(moment(), withoutSuffix);
                },

                calendar: function () {
                    var diff = this.diff(moment().startOf('day'), 'days', true),
                        format = diff < -6 ? 'sameElse' :
                        diff < -1 ? 'lastWeek' :
                        diff < 0 ? 'lastDay' :
                        diff < 1 ? 'sameDay' :
                        diff < 2 ? 'nextDay' :
                        diff < 7 ? 'nextWeek' : 'sameElse';
                    return this.format(this.lang().calendar(format, this));
                },

                isLeapYear: function () {
                    var year = this.year();
                    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
                },

                isDST: function () {
                    return (this.zone() < moment([this.year()]).zone() ||
                        this.zone() < moment([this.year(), 5]).zone());
                },

                day: function (input) {
                    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
                    return input == null ? day :
                        this.add({ d: input - day });
                },

                startOf: function (units) {
                    units = units.replace(/s$/, '');
                    // the following switch intentionally omits break keywords
                    // to utilize falling through the cases.
                    switch (units) {
                        case 'year':
                            this.month(0);
                            /* falls through */
                        case 'month':
                            this.date(1);
                            /* falls through */
                        case 'week':
                        case 'day':
                            this.hours(0);
                            /* falls through */
                        case 'hour':
                            this.minutes(0);
                            /* falls through */
                        case 'minute':
                            this.seconds(0);
                            /* falls through */
                        case 'second':
                            this.milliseconds(0);
                            /* falls through */
                    }

                    // weeks are a special case
                    if (units === 'week') {
                        this.day(0);
                    }

                    return this;
                },

                endOf: function (units) {
                    return this.startOf(units).add(units.replace(/s?$/, 's'), 1).subtract('ms', 1);
                },

                isAfter: function (input, units) {
                    units = typeof units !== 'undefined' ? units : 'millisecond';
                    return +this.clone().startOf(units) > +moment(input).startOf(units);
                },

                isBefore: function (input, units) {
                    units = typeof units !== 'undefined' ? units : 'millisecond';
                    return +this.clone().startOf(units) < +moment(input).startOf(units);
                },

                isSame: function (input, units) {
                    units = typeof units !== 'undefined' ? units : 'millisecond';
                    return +this.clone().startOf(units) === +moment(input).startOf(units);
                },

                zone: function () {
                    return this._isUTC ? 0 : this._d.getTimezoneOffset();
                },

                daysInMonth: function () {
                    return moment.utc([this.year(), this.month() + 1, 0]).date();
                },

                dayOfYear: function (input) {
                    var dayOfYear = round((moment(this).startOf('day') - moment(this).startOf('year')) / 864e5) + 1;
                    return input == null ? dayOfYear : this.add("d", (input - dayOfYear));
                },

                isoWeek: function (input) {
                    var week = weekOfYear(this, 1, 4);
                    return input == null ? week : this.add("d", (input - week) * 7);
                },

                week: function (input) {
                    var week = this.lang().week(this);
                    return input == null ? week : this.add("d", (input - week) * 7);
                },

                // If passed a language key, it will set the language for this
                // instance.  Otherwise, it will return the language configuration
                // variables for this instance.
                lang: function (key) {
                    if (key === undefined) {
                        return this._lang;
                    } else {
                        this._lang = getLangDefinition(key);
                        return this;
                    }
                }
            };

            // helper for adding shortcuts
            function makeGetterAndSetter(name, key) {
                moment.fn[name] = moment.fn[name + 's'] = function (input) {
                    var utc = this._isUTC ? 'UTC' : '';
                    if (input != null) {
                        this._d['set' + utc + key](input);
                        return this;
                    } else {
                        return this._d['get' + utc + key]();
                    }
                };
            }

            // loop through and add shortcuts (Month, Date, Hours, Minutes, Seconds, Milliseconds)
            for (i = 0; i < proxyGettersAndSetters.length; i++) {
                makeGetterAndSetter(proxyGettersAndSetters[i].toLowerCase().replace(/s$/, ''), proxyGettersAndSetters[i]);
            }

            // add shortcut for year (uses different syntax than the getter/setter 'year' == 'FullYear')
            makeGetterAndSetter('year', 'FullYear');

            // add plural methods
            moment.fn.days = moment.fn.day;
            moment.fn.weeks = moment.fn.week;
            moment.fn.isoWeeks = moment.fn.isoWeek;

            /************************************
                Duration Prototype
            ************************************/


            moment.duration.fn = Duration.prototype = {
                weeks: function () {
                    return absRound(this.days() / 7);
                },

                valueOf: function () {
                    return this._milliseconds +
                      this._days * 864e5 +
                      this._months * 2592e6;
                },

                humanize: function (withSuffix) {
                    var difference = +this,
                        output = relativeTime(difference, !withSuffix, this.lang());

                    if (withSuffix) {
                        output = this.lang().pastFuture(difference, output);
                    }

                    return this.lang().postformat(output);
                },

                lang: moment.fn.lang
            };

            function makeDurationGetter(name) {
                moment.duration.fn[name] = function () {
                    return this._data[name];
                };
            }

            function makeDurationAsGetter(name, factor) {
                moment.duration.fn['as' + name] = function () {
                    return +this / factor;
                };
            }

            for (i in unitMillisecondFactors) {
                if (unitMillisecondFactors.hasOwnProperty(i)) {
                    makeDurationAsGetter(i, unitMillisecondFactors[i]);
                    makeDurationGetter(i.toLowerCase());
                }
            }

            makeDurationAsGetter('Weeks', 6048e5);


            /************************************
                Default Lang
            ************************************/


            // Set default language, other languages will inherit from English.
            moment.lang('en', {
                ordinal: function (number) {
                    var b = number % 10,
                        output = (~~(number % 100 / 10) === 1) ? 'th' :
                        (b === 1) ? 'st' :
                        (b === 2) ? 'nd' :
                        (b === 3) ? 'rd' : 'th';
                    return number + output;
                }
            });


            /************************************
                Exposing Moment
            ************************************/


            // CommonJS module is defined
            if (hasModule) {
                module.exports = moment;
            }
            /*global ender:false */
            if (typeof ender === 'undefined') {
                // here, `this` means `window` in the browser, or `global` on the server
                // add `moment` as a global object via a string identifier,
                // for Closure Compiler "advanced" mode
                this['moment'] = moment;
            }
            /*global define:false */
            if (typeof define === "function" && define.amd) {
                define("moment", [], function () {
                    return moment;
                });
            }
        }).call(this);

    }, {}], 3: [function (require, module, exports) {
        var reqwest = require('reqwest'),
            qs = require('qs'),
            through = require('through');

        var osmStream = (function osmMinutely() {
            var s = {};

            // presets
            var baseUrl = './',
                minuteStatePath = 'augmented_diff_status',
                changePath = 'augmented_diff?';

            function minuteStateUrl() {
                return baseUrl + minuteStatePath;
            }

            function changeUrl(id, bbox) {
                return baseUrl + changePath + qs.stringify({
                    id: id, tags: 'hotosm', lookBack: '20'
                });
            }

            function requestState(cb) {
                reqwest({
                    url: minuteStateUrl(),
                    crossOrigin: true,
                    type: 'text',
                    success: function (res) {
                        cb(null, parseInt(res.response, 10));
                    }
                });
            }

            function requestChangeset(state, cb, bbox) {
                reqwest({
                    url: changeUrl(state, bbox),
                    crossOrigin: true,
                    type: 'xml',
                    success: function (res) {
                        cb(null, res);
                    }
                });
            }

            function meta(x) {
                return {
                    type: x.tagName,
                    user: x.getAttribute('user'),
                    timestamp: x.getAttribute('timestamp'),
                    changeset: +x.getAttribute('changeset'),
                    id: +x.getAttribute('id')
                };
            }

            function parseNode(x) {
                if (!x) return undefined;
                var o = meta(x);
                if (o.type === 'way') {
                    var bounds = get(x, ['bounds']);
                    o.bounds = [
                        +bounds.getAttribute('maxlat'),
                        +bounds.getAttribute('maxlon'),
                        +bounds.getAttribute('minlat'),
                        +bounds.getAttribute('minlon')];

                    var nds = x.getElementsByTagName('nd');
                    var nodes = [];
                    for (var i = 0; i < nds.length; i++) {
                        nodes.push([
                            +nds[i].getAttribute('lat'),
                            +nds[i].getAttribute('lon')
                        ]);
                    }
                    if (nodes.length > 0) {
                        o.linestring = nodes;
                    }

                    var tgs = x.getElementsByTagName('tag');
                    var tags = {};
                    for (var j = 0; j < tgs.length; j++) {
                        tags[tgs[j].getAttribute("k")] = tgs[j].getAttribute("v");
                    }
                    o.tags = tags;
                }
                return o;
            }

            function get(x, y) {
                if (!x) return undefined;
                for (var i = 0; i < y.length; i++) {
                    var o = x.getElementsByTagName(y[i])[0];
                    if (o) return o;
                }
            }

            function run(id, cb, bbox) {
                requestChangeset(id, function (err, xml) {
                    if (err) return cb('Error');
                    if (!xml.getElementsByTagName) return cb('No items');
                    var actions = xml.getElementsByTagName('action'), a;
                    var items = [];
                    for (var i = 0; i < actions.length; i++) {
                        var o = {};
                        a = actions[i];
                        o.type = a.getAttribute('type');
                        // ignore relations!
                        if (a.getElementsByTagName('relation').length) break;

                        if (o.type == 'modify') {

                            o.before = parseNode(get(get(a, ['old']), ['node', 'way']));
                            o.feature = parseNode(get(get(a, ['new']), ['node', 'way']));
                            var newNodeWay = get(get(a, ['new']), ['node', 'way']);
                            if (newNodeWay) {
                                o.meta = meta(newNodeWay);
                            }
                        } else if (o.type == 'delete') {
                            o.feature = parseNode(get(get(a, ['old']), ['node', 'way']));
                            var newNodeWay = get(get(a, ['new']), ['node', 'way']);
                            if (newNodeWay) {
                                o.meta = meta(newNodeWay);
                            }
                        } else if (o.type == 'create') {
                            o.feature = parseNode(get(a, ['node', 'way']));
                            var nodeWay = get(a, ['node', 'way']);
                            if (nodeWay) {
                                o.meta = meta(nodeWay);
                            }
                        }

                        if (o.feature && o.meta) {
                            items.push(o);
                        }
                    }

                    cb(null, items);
                }, bbox);
            }

            s.once = function (cb, bbox) {
                requestState(function (err, state) {
                    var stream = through(function write(err, data) {
                        cb(null, data);
                    });
                    run(state, stream.write, bbox);
                });
            };

            s.run = function (cb, duration, dir, bbox) {
                dir = dir || 1;
                duration = duration || 60 * 1000; // 60 * 1000;
                var cancel = false;
                function setCancel() { cancel = true; }
                requestState(function (err, state) {
                    var stream = through(
                        function write(data) {
                            this.queue(data);
                        },
                        function end() {
                            cancel = true;
                            this.queue(null);
                        });
                    function write(items) {
                        for (var i = 0; i < items.length; i++) {
                            stream.write(items[i]);
                        }
                    }
                    cb(null, stream);
                    function iterate() {
                        run(state, function (err, items) {
                            if (!err) {
                                write(items);
                                state += dir;
                            }
                            if (!cancel) setTimeout(iterate, duration);
                        }, bbox);
                    }
                    iterate();
                });
                return { cancel: setCancel };
            };

            s.runFn = function (cb, duration, dir, bbox) {
                dir = dir || 1;
                duration = duration || 60 * 1000; // 60 * 1000;
                function setCancel() { cancel = true; }
                var cancel = false;
                requestState(function (err, state) {
                    function write(items) { cb(null, items); }
                    function iterate() {
                        run(state, function (err, items) {
                            if (!err) {
                                write(items);
                                state += dir;
                            }
                            if (!cancel) setTimeout(iterate, duration);
                        }, bbox);
                    }
                    iterate();
                });
                return { cancel: setCancel };
            };

            return s;
        })();

        module.exports = osmStream;

    }, { "qs": 4, "reqwest": 6, "through": 5 }], 4: [function (require, module, exports) {

        /**
         * Object#toString() ref for stringify().
         */

        var toString = Object.prototype.toString;

        /**
         * Cache non-integer test regexp.
         */

        var isint = /^[0-9]+$/;

        function promote(parent, key) {
            if (parent[key].length == 0) return parent[key] = {};
            var t = {};
            for (var i in parent[key]) t[i] = parent[key][i];
            parent[key] = t;
            return t;
        }

        function parse(parts, parent, key, val) {
            var part = parts.shift();
            // end
            if (!part) {
                if (Array.isArray(parent[key])) {
                    parent[key].push(val);
                } else if ('object' == typeof parent[key]) {
                    parent[key] = val;
                } else if ('undefined' == typeof parent[key]) {
                    parent[key] = val;
                } else {
                    parent[key] = [parent[key], val];
                }
                // array
            } else {
                var obj = parent[key] = parent[key] || [];
                if (']' == part) {
                    if (Array.isArray(obj)) {
                        if ('' != val) obj.push(val);
                    } else if ('object' == typeof obj) {
                        obj[Object.keys(obj).length] = val;
                    } else {
                        obj = parent[key] = [parent[key], val];
                    }
                    // prop
                } else if (~part.indexOf(']')) {
                    part = part.substr(0, part.length - 1);
                    if (!isint.test(part) && Array.isArray(obj)) obj = promote(parent, key);
                    parse(parts, obj, part, val);
                    // key
                } else {
                    if (!isint.test(part) && Array.isArray(obj)) obj = promote(parent, key);
                    parse(parts, obj, part, val);
                }
            }
        }

        /**
         * Merge parent key/val pair.
         */

        function merge(parent, key, val) {
            if (~key.indexOf(']')) {
                var parts = key.split('[')
                  , len = parts.length
                  , last = len - 1;
                parse(parts, parent, 'base', val);
                // optimize
            } else {
                if (!isint.test(key) && Array.isArray(parent.base)) {
                    var t = {};
                    for (var k in parent.base) t[k] = parent.base[k];
                    parent.base = t;
                }
                set(parent.base, key, val);
            }

            return parent;
        }

        /**
         * Parse the given obj.
         */

        function parseObject(obj) {
            var ret = { base: {} };
            Object.keys(obj).forEach(function (name) {
                merge(ret, name, obj[name]);
            });
            return ret.base;
        }

        /**
         * Parse the given str.
         */

        function parseString(str) {
            return String(str)
              .split('&')
              .reduce(function (ret, pair) {
                  var eql = pair.indexOf('=')
                    , brace = lastBraceInKey(pair)
                    , key = pair.substr(0, brace || eql)
                    , val = pair.substr(brace || eql, pair.length)
                    , val = val.substr(val.indexOf('=') + 1, val.length);

                  // ?foo
                  if ('' == key) key = pair, val = '';
                  if ('' == key) return ret;

                  return merge(ret, decode(key), decode(val));
              }, { base: {} }).base;
        }

        /**
         * Parse the given query `str` or `obj`, returning an object.
         *
         * @param {String} str | {Object} obj
         * @return {Object}
         * @api public
         */

        exports.parse = function (str) {
            if (null == str || '' == str) return {};
            return 'object' == typeof str
              ? parseObject(str)
              : parseString(str);
        };

        /**
         * Turn the given `obj` into a query string
         *
         * @param {Object} obj
         * @return {String}
         * @api public
         */

        var stringify = exports.stringify = function (obj, prefix) {
            if (Array.isArray(obj)) {
                return stringifyArray(obj, prefix);
            } else if ('[object Object]' == toString.call(obj)) {
                return stringifyObject(obj, prefix);
            } else if ('string' == typeof obj) {
                return stringifyString(obj, prefix);
            } else {
                return prefix + '=' + encodeURIComponent(String(obj));
            }
        };

        /**
         * Stringify the given `str`.
         *
         * @param {String} str
         * @param {String} prefix
         * @return {String}
         * @api private
         */

        function stringifyString(str, prefix) {
            if (!prefix) throw new TypeError('stringify expects an object');
            return prefix + '=' + encodeURIComponent(str);
        }

        /**
         * Stringify the given `arr`.
         *
         * @param {Array} arr
         * @param {String} prefix
         * @return {String}
         * @api private
         */

        function stringifyArray(arr, prefix) {
            var ret = [];
            if (!prefix) throw new TypeError('stringify expects an object');
            for (var i = 0; i < arr.length; i++) {
                ret.push(stringify(arr[i], prefix + '[' + i + ']'));
            }
            return ret.join('&');
        }

        /**
         * Stringify the given `obj`.
         *
         * @param {Object} obj
         * @param {String} prefix
         * @return {String}
         * @api private
         */

        function stringifyObject(obj, prefix) {
            var ret = []
              , keys = Object.keys(obj)
              , key;

            for (var i = 0, len = keys.length; i < len; ++i) {
                key = keys[i];
                if ('' == key) continue;
                if (null == obj[key]) {
                    ret.push(encodeURIComponent(key) + '=');
                } else {
                    ret.push(stringify(obj[key], prefix
                      ? prefix + '[' + encodeURIComponent(key) + ']'
                      : encodeURIComponent(key)));
                }
            }

            return ret.join('&');
        }

        /**
         * Set `obj`'s `key` to `val` respecting
         * the weird and wonderful syntax of a qs,
         * where "foo=bar&foo=baz" becomes an array.
         *
         * @param {Object} obj
         * @param {String} key
         * @param {String} val
         * @api private
         */

        function set(obj, key, val) {
            var v = obj[key];
            if (undefined === v) {
                obj[key] = val;
            } else if (Array.isArray(v)) {
                v.push(val);
            } else {
                obj[key] = [v, val];
            }
        }

        /**
         * Locate last brace in `str` within the key.
         *
         * @param {String} str
         * @return {Number}
         * @api private
         */

        function lastBraceInKey(str) {
            var len = str.length
              , brace
              , c;
            for (var i = 0; i < len; ++i) {
                c = str[i];
                if (']' == c) brace = false;
                if ('[' == c) brace = true;
                if ('=' == c && !brace) return i;
            }
        }

        /**
         * Decode `str`.
         *
         * @param {String} str
         * @return {String}
         * @api private
         */

        function decode(str) {
            try {
                return decodeURIComponent(str.replace(/\+/g, ' '));
            } catch (err) {
                return str;
            }
        }

    }, {}], 5: [function (require, module, exports) {
        (function (process) {
            var Stream = require('stream')

            // through
            //
            // a stream that does nothing but re-emit the input.
            // useful for aggregating a series of changing but not ending streams into one stream)

            exports = module.exports = through
            through.through = through

            //create a readable writable stream.

            function through(write, end, opts) {
                write = write || function (data) { this.queue(data) }
                end = end || function () { this.queue(null) }

                var ended = false, destroyed = false, buffer = [], _ended = false
                var stream = new Stream()
                stream.readable = stream.writable = true
                stream.paused = false

                //  stream.autoPause   = !(opts && opts.autoPause   === false)
                stream.autoDestroy = !(opts && opts.autoDestroy === false)

                stream.write = function (data) {
                    write.call(this, data)
                    return !stream.paused
                }

                function drain() {
                    while (buffer.length && !stream.paused) {
                        var data = buffer.shift()
                        if (null === data)
                            return stream.emit('end')
                        else
                            stream.emit('data', data)
                    }
                }

                stream.queue = stream.push = function (data) {
                    //    console.error(ended)
                    if (_ended) return stream
                    if (data == null) _ended = true
                    buffer.push(data)
                    drain()
                    return stream
                }

                //this will be registered as the first 'end' listener
                //must call destroy next tick, to make sure we're after any
                //stream piped from here.
                //this is only a problem if end is not emitted synchronously.
                //a nicer way to do this is to make sure this is the last listener for 'end'

                stream.on('end', function () {
                    stream.readable = false
                    if (!stream.writable && stream.autoDestroy)
                        process.nextTick(function () {
                            stream.destroy()
                        })
                })

                function _end() {
                    stream.writable = false
                    end.call(stream)
                    if (!stream.readable && stream.autoDestroy)
                        stream.destroy()
                }

                stream.end = function (data) {
                    if (ended) return
                    ended = true
                    if (arguments.length) stream.write(data)
                    _end() // will emit or queue
                    return stream
                }

                stream.destroy = function () {
                    if (destroyed) return
                    destroyed = true
                    ended = true
                    buffer.length = 0
                    stream.writable = stream.readable = false
                    stream.emit('close')
                    return stream
                }

                stream.pause = function () {
                    if (stream.paused) return
                    stream.paused = true
                    return stream
                }

                stream.resume = function () {
                    if (stream.paused) {
                        stream.paused = false
                        stream.emit('resume')
                    }
                    drain()
                    //may have become paused again,
                    //as drain emits 'data'.
                    if (!stream.paused)
                        stream.emit('drain')
                    return stream
                }
                return stream
            }


        }).call(this, require('_process'))
    }, { "_process": 14, "stream": 27 }], 6: [function (require, module, exports) {
        /*!
          * Reqwest! A general purpose XHR connection manager
          * (c) Dustin Diaz 2013
          * https://github.com/ded/reqwest
          * license MIT
          */
        !function (name, context, definition) {
            if (typeof module != 'undefined' && module.exports) module.exports = definition()
            else if (typeof define == 'function' && define.amd) define(definition)
            else context[name] = definition()
        }('reqwest', this, function () {

            var win = window
              , doc = document
              , twoHundo = /^20\d$/
              , byTag = 'getElementsByTagName'
              , readyState = 'readyState'
              , contentType = 'Content-Type'
              , requestedWith = 'X-Requested-With'
              , head = doc[byTag]('head')[0]
              , uniqid = 0
              , callbackPrefix = 'reqwest_' + (+new Date())
              , lastValue // data stored by the most recent JSONP callback
              , xmlHttpRequest = 'XMLHttpRequest'
              , noop = function () { }

              , isArray = typeof Array.isArray == 'function'
                  ? Array.isArray
                  : function (a) {
                      return a instanceof Array
                  }

              , defaultHeaders = {
                  contentType: 'application/x-www-form-urlencoded'
                  , requestedWith: xmlHttpRequest
                  , accept: {
                      '*': 'text/javascript, text/html, application/xml, text/xml, */*'
                      , xml: 'application/xml, text/xml'
                      , html: 'text/html'
                      , text: 'text/plain'
                      , json: 'application/json, text/javascript'
                      , js: 'application/javascript, text/javascript'
                  }
              }

              , xhr = win[xmlHttpRequest]
                  ? function () {
                      return new XMLHttpRequest()
                  }
                  : function () {
                      return new ActiveXObject('Microsoft.XMLHTTP')
                  }
              , globalSetupOptions = {
                  dataFilter: function (data) {
                      return data
                  }
              }

            function handleReadyState(r, success, error) {
                return function () {
                    // use _aborted to mitigate against IE err c00c023f
                    // (can't read props on aborted request objects)
                    if (r._aborted) return error(r.request)
                    if (r.request && r.request[readyState] == 4) {
                        r.request.onreadystatechange = noop
                        if (twoHundo.test(r.request.status))
                            success(r.request)
                        else
                            error(r.request)
                    }
                }
            }

            function setHeaders(http, o) {
                var headers = o.headers || {}
                  , h

                headers.Accept = headers.Accept
                  || defaultHeaders.accept[o.type]
                  || defaultHeaders.accept['*']

                // breaks cross-origin requests with legacy browsers
                if (!o.crossOrigin && !headers[requestedWith]) headers[requestedWith] = defaultHeaders.requestedWith
                if (!headers[contentType]) headers[contentType] = o.contentType || defaultHeaders.contentType
                for (h in headers)
                    headers.hasOwnProperty(h) && http.setRequestHeader(h, headers[h])
            }

            function setCredentials(http, o) {
                if (typeof o.withCredentials !== 'undefined' && typeof http.withCredentials !== 'undefined') {
                    http.withCredentials = !!o.withCredentials
                }
            }

            function generalCallback(data) {
                lastValue = data
            }

            function urlappend(url, s) {
                return url + (/\?/.test(url) ? '&' : '?') + s
            }

            function handleJsonp(o, fn, err, url) {
                var reqId = uniqid++
                  , cbkey = o.jsonpCallback || 'callback' // the 'callback' key
                  , cbval = o.jsonpCallbackName || reqwest.getcallbackPrefix(reqId)
                  // , cbval = o.jsonpCallbackName || ('reqwest_' + reqId) // the 'callback' value
                  , cbreg = new RegExp('((^|\\?|&)' + cbkey + ')=([^&]+)')
                  , match = url.match(cbreg)
                  , script = doc.createElement('script')
                  , loaded = 0
                  , isIE10 = navigator.userAgent.indexOf('MSIE 10.0') !== -1

                if (match) {
                    if (match[3] === '?') {
                        url = url.replace(cbreg, '$1=' + cbval) // wildcard callback func name
                    } else {
                        cbval = match[3] // provided callback func name
                    }
                } else {
                    url = urlappend(url, cbkey + '=' + cbval) // no callback details, add 'em
                }

                win[cbval] = generalCallback

                script.type = 'text/javascript'
                script.src = url
                script.async = true
                if (typeof script.onreadystatechange !== 'undefined' && !isIE10) {
                    // need this for IE due to out-of-order onreadystatechange(), binding script
                    // execution to an event listener gives us control over when the script
                    // is executed. See http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html
                    //
                    // if this hack is used in IE10 jsonp callback are never called
                    script.event = 'onclick'
                    script.htmlFor = script.id = '_reqwest_' + reqId
                }

                script.onload = script.onreadystatechange = function () {
                    if ((script[readyState] && script[readyState] !== 'complete' && script[readyState] !== 'loaded') || loaded) {
                        return false
                    }
                    script.onload = script.onreadystatechange = null
                    script.onclick && script.onclick()
                    // Call the user callback with the last value stored and clean up values and scripts.
                    o.success && o.success(lastValue)
                    lastValue = undefined
                    head.removeChild(script)
                    loaded = 1
                }

                // Add the script to the DOM head
                head.appendChild(script)

                // Enable JSONP timeout
                return {
                    abort: function () {
                        script.onload = script.onreadystatechange = null
                        o.error && o.error({}, 'Request is aborted: timeout', {})
                        lastValue = undefined
                        head.removeChild(script)
                        loaded = 1
                    }
                }
            }

            function getRequest(fn, err) {
                var o = this.o
                  , method = (o.method || 'GET').toUpperCase()
                  , url = typeof o === 'string' ? o : o.url
                  // convert non-string objects to query-string form unless o.processData is false
                  , data = (o.processData !== false && o.data && typeof o.data !== 'string')
                    ? reqwest.toQueryString(o.data)
                    : (o.data || null)
                  , http

                // if we're working on a GET request and we have data then we should append
                // query string to end of URL and not post data
                if ((o.type == 'jsonp' || method == 'GET') && data) {
                    url = urlappend(url, data)
                    data = null
                }

                if (o.type == 'jsonp') return handleJsonp(o, fn, err, url)

                http = xhr()
                http.open(method, url, true)
                setHeaders(http, o)
                setCredentials(http, o)
                http.onreadystatechange = handleReadyState(this, fn, err)
                o.before && o.before(http)
                http.send(data)
                return http
            }

            function Reqwest(o, fn) {
                this.o = o
                this.fn = fn

                init.apply(this, arguments)
            }

            function setType(url) {
                var m = url.match(/\.(json|jsonp|html|xml)(\?|$)/)
                return m ? m[1] : 'js'
            }

            function init(o, fn) {

                this.url = typeof o == 'string' ? o : o.url
                this.timeout = null

                // whether request has been fulfilled for purpose
                // of tracking the Promises
                this._fulfilled = false
                // success handlers
                this._fulfillmentHandlers = []
                // error handlers
                this._errorHandlers = []
                // complete (both success and fail) handlers
                this._completeHandlers = []
                this._erred = false
                this._responseArgs = {}

                var self = this
                  , type = o.type || setType(this.url)

                fn = fn || function () { }

                if (o.timeout) {
                    this.timeout = setTimeout(function () {
                        self.abort()
                    }, o.timeout)
                }

                if (o.success) {
                    this._fulfillmentHandlers.push(function () {
                        o.success.apply(o, arguments)
                    })
                }

                if (o.error) {
                    this._errorHandlers.push(function () {
                        o.error.apply(o, arguments)
                    })
                }

                if (o.complete) {
                    this._completeHandlers.push(function () {
                        o.complete.apply(o, arguments)
                    })
                }

                function complete(resp) {
                    o.timeout && clearTimeout(self.timeout)
                    self.timeout = null
                    while (self._completeHandlers.length > 0) {
                        self._completeHandlers.shift()(resp)
                    }
                }

                function success(resp) {
                    // use global data filter on response text
                    var filteredResponse = globalSetupOptions.dataFilter(resp.responseText, type)
                      , r = resp.responseText = filteredResponse
                    if (r) {
                        switch (type) {
                            case 'json':
                                try {
                                    resp = win.JSON ? win.JSON.parse(r) : eval('(' + r + ')')
                                } catch (err) {
                                    return error(resp, 'Could not parse JSON in response', err)
                                }
                                break
                            case 'js':
                                resp = eval(r)
                                break
                            case 'html':
                                resp = r
                                break
                            case 'xml':
                                resp = resp.responseXML
                                    && resp.responseXML.parseError // IE trololo
                                    && resp.responseXML.parseError.errorCode
                                    && resp.responseXML.parseError.reason
                                  ? null
                                  : resp.responseXML
                                break
                        }
                    }

                    self._responseArgs.resp = resp
                    self._fulfilled = true
                    fn(resp)
                    while (self._fulfillmentHandlers.length > 0) {
                        self._fulfillmentHandlers.shift()(resp)
                    }

                    complete(resp)
                }

                function error(resp, msg, t) {
                    self._responseArgs.resp = resp
                    self._responseArgs.msg = msg
                    self._responseArgs.t = t
                    self._erred = true
                    while (self._errorHandlers.length > 0) {
                        self._errorHandlers.shift()(resp, msg, t)
                    }
                    complete(resp)
                }

                this.request = getRequest.call(this, success, error)
            }

            Reqwest.prototype = {
                abort: function () {
                    this._aborted = true
                    this.request.abort()
                }

            , retry: function () {
                init.call(this, this.o, this.fn)
            }

                /**
                 * Small deviation from the Promises A CommonJs specification
                 * http://wiki.commonjs.org/wiki/Promises/A
                 */

                /**
                 * `then` will execute upon successful requests
                 */
            , then: function (success, fail) {
                if (this._fulfilled) {
                    success(this._responseArgs.resp)
                } else if (this._erred) {
                    fail(this._responseArgs.resp, this._responseArgs.msg, this._responseArgs.t)
                } else {
                    this._fulfillmentHandlers.push(success)
                    this._errorHandlers.push(fail)
                }
                return this
            }

                /**
                 * `always` will execute whether the request succeeds or fails
                 */
            , always: function (fn) {
                if (this._fulfilled || this._erred) {
                    fn(this._responseArgs.resp)
                } else {
                    this._completeHandlers.push(fn)
                }
                return this
            }

                /**
                 * `fail` will execute when the request fails
                 */
            , fail: function (fn) {
                if (this._erred) {
                    fn(this._responseArgs.resp, this._responseArgs.msg, this._responseArgs.t)
                } else {
                    this._errorHandlers.push(fn)
                }
                return this
            }
            }

            function reqwest(o, fn) {
                return new Reqwest(o, fn)
            }

            // normalize newline variants according to spec -> CRLF
            function normalize(s) {
                return s ? s.replace(/\r?\n/g, '\r\n') : ''
            }

            function serial(el, cb) {
                var n = el.name
                  , t = el.tagName.toLowerCase()
                  , optCb = function (o) {
                      // IE gives value="" even where there is no value attribute
                      // 'specified' ref: http://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-862529273
                      if (o && !o.disabled)
                          cb(n, normalize(o.attributes.value && o.attributes.value.specified ? o.value : o.text))
                  }
                  , ch, ra, val, i

                // don't serialize elements that are disabled or without a name
                if (el.disabled || !n) return

                switch (t) {
                    case 'input':
                        if (!/reset|button|image|file/i.test(el.type)) {
                            ch = /checkbox/i.test(el.type)
                            ra = /radio/i.test(el.type)
                            val = el.value
                            // WebKit gives us "" instead of "on" if a checkbox has no value, so correct it here
                            ; (!(ch || ra) || el.checked) && cb(n, normalize(ch && val === '' ? 'on' : val))
                        }
                        break
                    case 'textarea':
                        cb(n, normalize(el.value))
                        break
                    case 'select':
                        if (el.type.toLowerCase() === 'select-one') {
                            optCb(el.selectedIndex >= 0 ? el.options[el.selectedIndex] : null)
                        } else {
                            for (i = 0; el.length && i < el.length; i++) {
                                el.options[i].selected && optCb(el.options[i])
                            }
                        }
                        break
                }
            }

            // collect up all form elements found from the passed argument elements all
            // the way down to child elements; pass a '<form>' or form fields.
            // called with 'this'=callback to use for serial() on each element
            function eachFormElement() {
                var cb = this
                  , e, i
                  , serializeSubtags = function (e, tags) {
                      var i, j, fa
                      for (i = 0; i < tags.length; i++) {
                          fa = e[byTag](tags[i])
                          for (j = 0; j < fa.length; j++) serial(fa[j], cb)
                      }
                  }

                for (i = 0; i < arguments.length; i++) {
                    e = arguments[i]
                    if (/input|select|textarea/i.test(e.tagName)) serial(e, cb)
                    serializeSubtags(e, ['input', 'select', 'textarea'])
                }
            }

            // standard query string style serialization
            function serializeQueryString() {
                return reqwest.toQueryString(reqwest.serializeArray.apply(null, arguments))
            }

            // { 'name': 'value', ... } style serialization
            function serializeHash() {
                var hash = {}
                eachFormElement.apply(function (name, value) {
                    if (name in hash) {
                        hash[name] && !isArray(hash[name]) && (hash[name] = [hash[name]])
                        hash[name].push(value)
                    } else hash[name] = value
                }, arguments)
                return hash
            }

            // [ { name: 'name', value: 'value' }, ... ] style serialization
            reqwest.serializeArray = function () {
                var arr = []
                eachFormElement.apply(function (name, value) {
                    arr.push({ name: name, value: value })
                }, arguments)
                return arr
            }

            reqwest.serialize = function () {
                if (arguments.length === 0) return ''
                var opt, fn
                  , args = Array.prototype.slice.call(arguments, 0)

                opt = args.pop()
                opt && opt.nodeType && args.push(opt) && (opt = null)
                opt && (opt = opt.type)

                if (opt == 'map') fn = serializeHash
                else if (opt == 'array') fn = reqwest.serializeArray
                else fn = serializeQueryString

                return fn.apply(null, args)
            }

            reqwest.toQueryString = function (o, trad) {
                var prefix, i
                  , traditional = trad || false
                  , s = []
                  , enc = encodeURIComponent
                  , add = function (key, value) {
                      // If value is a function, invoke it and return its value
                      value = ('function' === typeof value) ? value() : (value == null ? '' : value)
                      s[s.length] = enc(key) + '=' + enc(value)
                  }
                // If an array was passed in, assume that it is an array of form elements.
                if (isArray(o)) {
                    for (i = 0; o && i < o.length; i++) add(o[i].name, o[i].value)
                } else {
                    // If traditional, encode the "old" way (the way 1.3.2 or older
                    // did it), otherwise encode params recursively.
                    for (prefix in o) {
                        buildParams(prefix, o[prefix], traditional, add)
                    }
                }

                // spaces should be + according to spec
                return s.join('&').replace(/%20/g, '+')
            }

            function buildParams(prefix, obj, traditional, add) {
                var name, i, v
                  , rbracket = /\[\]$/

                if (isArray(obj)) {
                    // Serialize array item.
                    for (i = 0; obj && i < obj.length; i++) {
                        v = obj[i]
                        if (traditional || rbracket.test(prefix)) {
                            // Treat each array item as a scalar.
                            add(prefix, v)
                        } else {
                            buildParams(prefix + '[' + (typeof v === 'object' ? i : '') + ']', v, traditional, add)
                        }
                    }
                } else if (obj.toString() === '[object Object]') {
                    // Serialize object item.
                    for (name in obj) {
                        buildParams(prefix + '[' + name + ']', obj[name], traditional, add)
                    }

                } else {
                    // Serialize scalar item.
                    add(prefix, obj)
                }
            }

            reqwest.getcallbackPrefix = function () {
                return callbackPrefix
            }

            // jQuery and Zepto compatibility, differences can be remapped here so you can call
            // .ajax.compat(options, callback)
            reqwest.compat = function (o, fn) {
                if (o) {
                    o.type && (o.method = o.type) && delete o.type
                    o.dataType && (o.type = o.dataType)
                    o.jsonpCallback && (o.jsonpCallbackName = o.jsonpCallback) && delete o.jsonpCallback
                    o.jsonp && (o.jsonpCallback = o.jsonp)
                }
                return new Reqwest(o, fn)
            }

            reqwest.ajaxSetup = function (options) {
                options = options || {}
                for (var k in options) {
                    globalSetupOptions[k] = options[k]
                }
            }

            return reqwest
        });

    }, {}], 7: [function (require, module, exports) {
        //     Underscore.js 1.4.4
        //     http://underscorejs.org
        //     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.
        //     Underscore may be freely distributed under the MIT license.

        (function () {

            // Baseline setup
            // --------------

            // Establish the root object, `window` in the browser, or `global` on the server.
            var root = this;

            // Save the previous value of the `_` variable.
            var previousUnderscore = root._;

            // Establish the object that gets returned to break out of a loop iteration.
            var breaker = {};

            // Save bytes in the minified (but not gzipped) version:
            var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

            // Create quick reference variables for speed access to core prototypes.
            var push = ArrayProto.push,
                slice = ArrayProto.slice,
                concat = ArrayProto.concat,
                toString = ObjProto.toString,
                hasOwnProperty = ObjProto.hasOwnProperty;

            // All **ECMAScript 5** native function implementations that we hope to use
            // are declared here.
            var
              nativeForEach = ArrayProto.forEach,
              nativeMap = ArrayProto.map,
              nativeReduce = ArrayProto.reduce,
              nativeReduceRight = ArrayProto.reduceRight,
              nativeFilter = ArrayProto.filter,
              nativeEvery = ArrayProto.every,
              nativeSome = ArrayProto.some,
              nativeIndexOf = ArrayProto.indexOf,
              nativeLastIndexOf = ArrayProto.lastIndexOf,
              nativeIsArray = Array.isArray,
              nativeKeys = Object.keys,
              nativeBind = FuncProto.bind;

            // Create a safe reference to the Underscore object for use below.
            var _ = function (obj) {
                if (obj instanceof _) return obj;
                if (!(this instanceof _)) return new _(obj);
                this._wrapped = obj;
            };

            // Export the Underscore object for **Node.js**, with
            // backwards-compatibility for the old `require()` API. If we're in
            // the browser, add `_` as a global object via a string identifier,
            // for Closure Compiler "advanced" mode.
            if (typeof exports !== 'undefined') {
                if (typeof module !== 'undefined' && module.exports) {
                    exports = module.exports = _;
                }
                exports._ = _;
            } else {
                root._ = _;
            }

            // Current version.
            _.VERSION = '1.4.4';

            // Collection Functions
            // --------------------

            // The cornerstone, an `each` implementation, aka `forEach`.
            // Handles objects with the built-in `forEach`, arrays, and raw objects.
            // Delegates to **ECMAScript 5**'s native `forEach` if available.
            var each = _.each = _.forEach = function (obj, iterator, context) {
                if (obj == null) return;
                if (nativeForEach && obj.forEach === nativeForEach) {
                    obj.forEach(iterator, context);
                } else if (obj.length === +obj.length) {
                    for (var i = 0, l = obj.length; i < l; i++) {
                        if (iterator.call(context, obj[i], i, obj) === breaker) return;
                    }
                } else {
                    for (var key in obj) {
                        if (_.has(obj, key)) {
                            if (iterator.call(context, obj[key], key, obj) === breaker) return;
                        }
                    }
                }
            };

            // Return the results of applying the iterator to each element.
            // Delegates to **ECMAScript 5**'s native `map` if available.
            _.map = _.collect = function (obj, iterator, context) {
                var results = [];
                if (obj == null) return results;
                if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
                each(obj, function (value, index, list) {
                    results[results.length] = iterator.call(context, value, index, list);
                });
                return results;
            };

            var reduceError = 'Reduce of empty array with no initial value';

            // **Reduce** builds up a single result from a list of values, aka `inject`,
            // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
            _.reduce = _.foldl = _.inject = function (obj, iterator, memo, context) {
                var initial = arguments.length > 2;
                if (obj == null) obj = [];
                if (nativeReduce && obj.reduce === nativeReduce) {
                    if (context) iterator = _.bind(iterator, context);
                    return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
                }
                each(obj, function (value, index, list) {
                    if (!initial) {
                        memo = value;
                        initial = true;
                    } else {
                        memo = iterator.call(context, memo, value, index, list);
                    }
                });
                if (!initial) throw new TypeError(reduceError);
                return memo;
            };

            // The right-associative version of reduce, also known as `foldr`.
            // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
            _.reduceRight = _.foldr = function (obj, iterator, memo, context) {
                var initial = arguments.length > 2;
                if (obj == null) obj = [];
                if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
                    if (context) iterator = _.bind(iterator, context);
                    return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
                }
                var length = obj.length;
                if (length !== +length) {
                    var keys = _.keys(obj);
                    length = keys.length;
                }
                each(obj, function (value, index, list) {
                    index = keys ? keys[--length] : --length;
                    if (!initial) {
                        memo = obj[index];
                        initial = true;
                    } else {
                        memo = iterator.call(context, memo, obj[index], index, list);
                    }
                });
                if (!initial) throw new TypeError(reduceError);
                return memo;
            };

            // Return the first value which passes a truth test. Aliased as `detect`.
            _.find = _.detect = function (obj, iterator, context) {
                var result;
                any(obj, function (value, index, list) {
                    if (iterator.call(context, value, index, list)) {
                        result = value;
                        return true;
                    }
                });
                return result;
            };

            // Return all the elements that pass a truth test.
            // Delegates to **ECMAScript 5**'s native `filter` if available.
            // Aliased as `select`.
            _.filter = _.select = function (obj, iterator, context) {
                var results = [];
                if (obj == null) return results;
                if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
                each(obj, function (value, index, list) {
                    if (iterator.call(context, value, index, list)) results[results.length] = value;
                });
                return results;
            };

            // Return all the elements for which a truth test fails.
            _.reject = function (obj, iterator, context) {
                return _.filter(obj, function (value, index, list) {
                    return !iterator.call(context, value, index, list);
                }, context);
            };

            // Determine whether all of the elements match a truth test.
            // Delegates to **ECMAScript 5**'s native `every` if available.
            // Aliased as `all`.
            _.every = _.all = function (obj, iterator, context) {
                iterator || (iterator = _.identity);
                var result = true;
                if (obj == null) return result;
                if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
                each(obj, function (value, index, list) {
                    if (!(result = result && iterator.call(context, value, index, list))) return breaker;
                });
                return !!result;
            };

            // Determine if at least one element in the object matches a truth test.
            // Delegates to **ECMAScript 5**'s native `some` if available.
            // Aliased as `any`.
            var any = _.some = _.any = function (obj, iterator, context) {
                iterator || (iterator = _.identity);
                var result = false;
                if (obj == null) return result;
                if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
                each(obj, function (value, index, list) {
                    if (result || (result = iterator.call(context, value, index, list))) return breaker;
                });
                return !!result;
            };

            // Determine if the array or object contains a given value (using `===`).
            // Aliased as `include`.
            _.contains = _.include = function (obj, target) {
                if (obj == null) return false;
                if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
                return any(obj, function (value) {
                    return value === target;
                });
            };

            // Invoke a method (with arguments) on every item in a collection.
            _.invoke = function (obj, method) {
                var args = slice.call(arguments, 2);
                var isFunc = _.isFunction(method);
                return _.map(obj, function (value) {
                    return (isFunc ? method : value[method]).apply(value, args);
                });
            };

            // Convenience version of a common use case of `map`: fetching a property.
            _.pluck = function (obj, key) {
                return _.map(obj, function (value) { return value[key]; });
            };

            // Convenience version of a common use case of `filter`: selecting only objects
            // containing specific `key:value` pairs.
            _.where = function (obj, attrs, first) {
                if (_.isEmpty(attrs)) return first ? null : [];
                return _[first ? 'find' : 'filter'](obj, function (value) {
                    for (var key in attrs) {
                        if (attrs[key] !== value[key]) return false;
                    }
                    return true;
                });
            };

            // Convenience version of a common use case of `find`: getting the first object
            // containing specific `key:value` pairs.
            _.findWhere = function (obj, attrs) {
                return _.where(obj, attrs, true);
            };

            // Return the maximum element or (element-based computation).
            // Can't optimize arrays of integers longer than 65,535 elements.
            // See: https://bugs.webkit.org/show_bug.cgi?id=80797
            _.max = function (obj, iterator, context) {
                if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
                    return Math.max.apply(Math, obj);
                }
                if (!iterator && _.isEmpty(obj)) return -Infinity;
                var result = { computed: -Infinity, value: -Infinity };
                each(obj, function (value, index, list) {
                    var computed = iterator ? iterator.call(context, value, index, list) : value;
                    computed >= result.computed && (result = { value: value, computed: computed });
                });
                return result.value;
            };

            // Return the minimum element (or element-based computation).
            _.min = function (obj, iterator, context) {
                if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
                    return Math.min.apply(Math, obj);
                }
                if (!iterator && _.isEmpty(obj)) return Infinity;
                var result = { computed: Infinity, value: Infinity };
                each(obj, function (value, index, list) {
                    var computed = iterator ? iterator.call(context, value, index, list) : value;
                    computed < result.computed && (result = { value: value, computed: computed });
                });
                return result.value;
            };

            // Shuffle an array.
            _.shuffle = function (obj) {
                var rand;
                var index = 0;
                var shuffled = [];
                each(obj, function (value) {
                    rand = _.random(index++);
                    shuffled[index - 1] = shuffled[rand];
                    shuffled[rand] = value;
                });
                return shuffled;
            };

            // An internal function to generate lookup iterators.
            var lookupIterator = function (value) {
                return _.isFunction(value) ? value : function (obj) { return obj[value]; };
            };

            // Sort the object's values by a criterion produced by an iterator.
            _.sortBy = function (obj, value, context) {
                var iterator = lookupIterator(value);
                return _.pluck(_.map(obj, function (value, index, list) {
                    return {
                        value: value,
                        index: index,
                        criteria: iterator.call(context, value, index, list)
                    };
                }).sort(function (left, right) {
                    var a = left.criteria;
                    var b = right.criteria;
                    if (a !== b) {
                        if (a > b || a === void 0) return 1;
                        if (a < b || b === void 0) return -1;
                    }
                    return left.index < right.index ? -1 : 1;
                }), 'value');
            };

            // An internal function used for aggregate "group by" operations.
            var group = function (obj, value, context, behavior) {
                var result = {};
                var iterator = lookupIterator(value || _.identity);
                each(obj, function (value, index) {
                    var key = iterator.call(context, value, index, obj);
                    behavior(result, key, value);
                });
                return result;
            };

            // Groups the object's values by a criterion. Pass either a string attribute
            // to group by, or a function that returns the criterion.
            _.groupBy = function (obj, value, context) {
                return group(obj, value, context, function (result, key, value) {
                    (_.has(result, key) ? result[key] : (result[key] = [])).push(value);
                });
            };

            // Counts instances of an object that group by a certain criterion. Pass
            // either a string attribute to count by, or a function that returns the
            // criterion.
            _.countBy = function (obj, value, context) {
                return group(obj, value, context, function (result, key) {
                    if (!_.has(result, key)) result[key] = 0;
                    result[key]++;
                });
            };

            // Use a comparator function to figure out the smallest index at which
            // an object should be inserted so as to maintain order. Uses binary search.
            _.sortedIndex = function (array, obj, iterator, context) {
                iterator = iterator == null ? _.identity : lookupIterator(iterator);
                var value = iterator.call(context, obj);
                var low = 0, high = array.length;
                while (low < high) {
                    var mid = (low + high) >>> 1;
                    iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
                }
                return low;
            };

            // Safely convert anything iterable into a real, live array.
            _.toArray = function (obj) {
                if (!obj) return [];
                if (_.isArray(obj)) return slice.call(obj);
                if (obj.length === +obj.length) return _.map(obj, _.identity);
                return _.values(obj);
            };

            // Return the number of elements in an object.
            _.size = function (obj) {
                if (obj == null) return 0;
                return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;
            };

            // Array Functions
            // ---------------

            // Get the first element of an array. Passing **n** will return the first N
            // values in the array. Aliased as `head` and `take`. The **guard** check
            // allows it to work with `_.map`.
            _.first = _.head = _.take = function (array, n, guard) {
                if (array == null) return void 0;
                return (n != null) && !guard ? slice.call(array, 0, n) : array[0];
            };

            // Returns everything but the last entry of the array. Especially useful on
            // the arguments object. Passing **n** will return all the values in
            // the array, excluding the last N. The **guard** check allows it to work with
            // `_.map`.
            _.initial = function (array, n, guard) {
                return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
            };

            // Get the last element of an array. Passing **n** will return the last N
            // values in the array. The **guard** check allows it to work with `_.map`.
            _.last = function (array, n, guard) {
                if (array == null) return void 0;
                if ((n != null) && !guard) {
                    return slice.call(array, Math.max(array.length - n, 0));
                } else {
                    return array[array.length - 1];
                }
            };

            // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
            // Especially useful on the arguments object. Passing an **n** will return
            // the rest N values in the array. The **guard**
            // check allows it to work with `_.map`.
            _.rest = _.tail = _.drop = function (array, n, guard) {
                return slice.call(array, (n == null) || guard ? 1 : n);
            };

            // Trim out all falsy values from an array.
            _.compact = function (array) {
                return _.filter(array, _.identity);
            };

            // Internal implementation of a recursive `flatten` function.
            var flatten = function (input, shallow, output) {
                each(input, function (value) {
                    if (_.isArray(value)) {
                        shallow ? push.apply(output, value) : flatten(value, shallow, output);
                    } else {
                        output.push(value);
                    }
                });
                return output;
            };

            // Return a completely flattened version of an array.
            _.flatten = function (array, shallow) {
                return flatten(array, shallow, []);
            };

            // Return a version of the array that does not contain the specified value(s).
            _.without = function (array) {
                return _.difference(array, slice.call(arguments, 1));
            };

            // Produce a duplicate-free version of the array. If the array has already
            // been sorted, you have the option of using a faster algorithm.
            // Aliased as `unique`.
            _.uniq = _.unique = function (array, isSorted, iterator, context) {
                if (_.isFunction(isSorted)) {
                    context = iterator;
                    iterator = isSorted;
                    isSorted = false;
                }
                var initial = iterator ? _.map(array, iterator, context) : array;
                var results = [];
                var seen = [];
                each(initial, function (value, index) {
                    if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {
                        seen.push(value);
                        results.push(array[index]);
                    }
                });
                return results;
            };

            // Produce an array that contains the union: each distinct element from all of
            // the passed-in arrays.
            _.union = function () {
                return _.uniq(concat.apply(ArrayProto, arguments));
            };

            // Produce an array that contains every item shared between all the
            // passed-in arrays.
            _.intersection = function (array) {
                var rest = slice.call(arguments, 1);
                return _.filter(_.uniq(array), function (item) {
                    return _.every(rest, function (other) {
                        return _.indexOf(other, item) >= 0;
                    });
                });
            };

            // Take the difference between one array and a number of other arrays.
            // Only the elements present in just the first array will remain.
            _.difference = function (array) {
                var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
                return _.filter(array, function (value) { return !_.contains(rest, value); });
            };

            // Zip together multiple lists into a single array -- elements that share
            // an index go together.
            _.zip = function () {
                var args = slice.call(arguments);
                var length = _.max(_.pluck(args, 'length'));
                var results = new Array(length);
                for (var i = 0; i < length; i++) {
                    results[i] = _.pluck(args, "" + i);
                }
                return results;
            };

            // Converts lists into objects. Pass either a single array of `[key, value]`
            // pairs, or two parallel arrays of the same length -- one of keys, and one of
            // the corresponding values.
            _.object = function (list, values) {
                if (list == null) return {};
                var result = {};
                for (var i = 0, l = list.length; i < l; i++) {
                    if (values) {
                        result[list[i]] = values[i];
                    } else {
                        result[list[i][0]] = list[i][1];
                    }
                }
                return result;
            };

            // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
            // we need this function. Return the position of the first occurrence of an
            // item in an array, or -1 if the item is not included in the array.
            // Delegates to **ECMAScript 5**'s native `indexOf` if available.
            // If the array is large and already in sort order, pass `true`
            // for **isSorted** to use binary search.
            _.indexOf = function (array, item, isSorted) {
                if (array == null) return -1;
                var i = 0, l = array.length;
                if (isSorted) {
                    if (typeof isSorted == 'number') {
                        i = (isSorted < 0 ? Math.max(0, l + isSorted) : isSorted);
                    } else {
                        i = _.sortedIndex(array, item);
                        return array[i] === item ? i : -1;
                    }
                }
                if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
                for (; i < l; i++) if (array[i] === item) return i;
                return -1;
            };

            // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
            _.lastIndexOf = function (array, item, from) {
                if (array == null) return -1;
                var hasIndex = from != null;
                if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
                    return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
                }
                var i = (hasIndex ? from : array.length);
                while (i--) if (array[i] === item) return i;
                return -1;
            };

            // Generate an integer Array containing an arithmetic progression. A port of
            // the native Python `range()` function. See
            // [the Python documentation](http://docs.python.org/library/functions.html#range).
            _.range = function (start, stop, step) {
                if (arguments.length <= 1) {
                    stop = start || 0;
                    start = 0;
                }
                step = arguments[2] || 1;

                var len = Math.max(Math.ceil((stop - start) / step), 0);
                var idx = 0;
                var range = new Array(len);

                while (idx < len) {
                    range[idx++] = start;
                    start += step;
                }

                return range;
            };

            // Function (ahem) Functions
            // ------------------

            // Create a function bound to a given object (assigning `this`, and arguments,
            // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
            // available.
            _.bind = function (func, context) {
                if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
                var args = slice.call(arguments, 2);
                return function () {
                    return func.apply(context, args.concat(slice.call(arguments)));
                };
            };

            // Partially apply a function by creating a version that has had some of its
            // arguments pre-filled, without changing its dynamic `this` context.
            _.partial = function (func) {
                var args = slice.call(arguments, 1);
                return function () {
                    return func.apply(this, args.concat(slice.call(arguments)));
                };
            };

            // Bind all of an object's methods to that object. Useful for ensuring that
            // all callbacks defined on an object belong to it.
            _.bindAll = function (obj) {
                var funcs = slice.call(arguments, 1);
                if (funcs.length === 0) funcs = _.functions(obj);
                each(funcs, function (f) { obj[f] = _.bind(obj[f], obj); });
                return obj;
            };

            // Memoize an expensive function by storing its results.
            _.memoize = function (func, hasher) {
                var memo = {};
                hasher || (hasher = _.identity);
                return function () {
                    var key = hasher.apply(this, arguments);
                    return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
                };
            };

            // Delays a function for the given number of milliseconds, and then calls
            // it with the arguments supplied.
            _.delay = function (func, wait) {
                var args = slice.call(arguments, 2);
                return setTimeout(function () { return func.apply(null, args); }, wait);
            };

            // Defers a function, scheduling it to run after the current call stack has
            // cleared.
            _.defer = function (func) {
                return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
            };

            // Returns a function, that, when invoked, will only be triggered at most once
            // during a given window of time.
            _.throttle = function (func, wait) {
                var context, args, timeout, result;
                var previous = 0;
                var later = function () {
                    previous = new Date;
                    timeout = null;
                    result = func.apply(context, args);
                };
                return function () {
                    var now = new Date;
                    var remaining = wait - (now - previous);
                    context = this;
                    args = arguments;
                    if (remaining <= 0) {
                        clearTimeout(timeout);
                        timeout = null;
                        previous = now;
                        result = func.apply(context, args);
                    } else if (!timeout) {
                        timeout = setTimeout(later, remaining);
                    }
                    return result;
                };
            };

            // Returns a function, that, as long as it continues to be invoked, will not
            // be triggered. The function will be called after it stops being called for
            // N milliseconds. If `immediate` is passed, trigger the function on the
            // leading edge, instead of the trailing.
            _.debounce = function (func, wait, immediate) {
                var timeout, result;
                return function () {
                    var context = this, args = arguments;
                    var later = function () {
                        timeout = null;
                        if (!immediate) result = func.apply(context, args);
                    };
                    var callNow = immediate && !timeout;
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                    if (callNow) result = func.apply(context, args);
                    return result;
                };
            };

            // Returns a function that will be executed at most one time, no matter how
            // often you call it. Useful for lazy initialization.
            _.once = function (func) {
                var ran = false, memo;
                return function () {
                    if (ran) return memo;
                    ran = true;
                    memo = func.apply(this, arguments);
                    func = null;
                    return memo;
                };
            };

            // Returns the first function passed as an argument to the second,
            // allowing you to adjust arguments, run code before and after, and
            // conditionally execute the original function.
            _.wrap = function (func, wrapper) {
                return function () {
                    var args = [func];
                    push.apply(args, arguments);
                    return wrapper.apply(this, args);
                };
            };

            // Returns a function that is the composition of a list of functions, each
            // consuming the return value of the function that follows.
            _.compose = function () {
                var funcs = arguments;
                return function () {
                    var args = arguments;
                    for (var i = funcs.length - 1; i >= 0; i--) {
                        args = [funcs[i].apply(this, args)];
                    }
                    return args[0];
                };
            };

            // Returns a function that will only be executed after being called N times.
            _.after = function (times, func) {
                if (times <= 0) return func();
                return function () {
                    if (--times < 1) {
                        return func.apply(this, arguments);
                    }
                };
            };

            // Object Functions
            // ----------------

            // Retrieve the names of an object's properties.
            // Delegates to **ECMAScript 5**'s native `Object.keys`
            _.keys = nativeKeys || function (obj) {
                if (obj !== Object(obj)) throw new TypeError('Invalid object');
                var keys = [];
                for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;
                return keys;
            };

            // Retrieve the values of an object's properties.
            _.values = function (obj) {
                var values = [];
                for (var key in obj) if (_.has(obj, key)) values.push(obj[key]);
                return values;
            };

            // Convert an object into a list of `[key, value]` pairs.
            _.pairs = function (obj) {
                var pairs = [];
                for (var key in obj) if (_.has(obj, key)) pairs.push([key, obj[key]]);
                return pairs;
            };

            // Invert the keys and values of an object. The values must be serializable.
            _.invert = function (obj) {
                var result = {};
                for (var key in obj) if (_.has(obj, key)) result[obj[key]] = key;
                return result;
            };

            // Return a sorted list of the function names available on the object.
            // Aliased as `methods`
            _.functions = _.methods = function (obj) {
                var names = [];
                for (var key in obj) {
                    if (_.isFunction(obj[key])) names.push(key);
                }
                return names.sort();
            };

            // Extend a given object with all the properties in passed-in object(s).
            _.extend = function (obj) {
                each(slice.call(arguments, 1), function (source) {
                    if (source) {
                        for (var prop in source) {
                            obj[prop] = source[prop];
                        }
                    }
                });
                return obj;
            };

            // Return a copy of the object only containing the whitelisted properties.
            _.pick = function (obj) {
                var copy = {};
                var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
                each(keys, function (key) {
                    if (key in obj) copy[key] = obj[key];
                });
                return copy;
            };

            // Return a copy of the object without the blacklisted properties.
            _.omit = function (obj) {
                var copy = {};
                var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
                for (var key in obj) {
                    if (!_.contains(keys, key)) copy[key] = obj[key];
                }
                return copy;
            };

            // Fill in a given object with default properties.
            _.defaults = function (obj) {
                each(slice.call(arguments, 1), function (source) {
                    if (source) {
                        for (var prop in source) {
                            if (obj[prop] == null) obj[prop] = source[prop];
                        }
                    }
                });
                return obj;
            };

            // Create a (shallow-cloned) duplicate of an object.
            _.clone = function (obj) {
                if (!_.isObject(obj)) return obj;
                return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
            };

            // Invokes interceptor with the obj, and then returns obj.
            // The primary purpose of this method is to "tap into" a method chain, in
            // order to perform operations on intermediate results within the chain.
            _.tap = function (obj, interceptor) {
                interceptor(obj);
                return obj;
            };

            // Internal recursive comparison function for `isEqual`.
            var eq = function (a, b, aStack, bStack) {
                // Identical objects are equal. `0 === -0`, but they aren't identical.
                // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.
                if (a === b) return a !== 0 || 1 / a == 1 / b;
                // A strict comparison is necessary because `null == undefined`.
                if (a == null || b == null) return a === b;
                // Unwrap any wrapped objects.
                if (a instanceof _) a = a._wrapped;
                if (b instanceof _) b = b._wrapped;
                // Compare `[[Class]]` names.
                var className = toString.call(a);
                if (className != toString.call(b)) return false;
                switch (className) {
                    // Strings, numbers, dates, and booleans are compared by value.
                    case '[object String]':
                        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
                        // equivalent to `new String("5")`.
                        return a == String(b);
                    case '[object Number]':
                        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
                        // other numeric values.
                        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
                    case '[object Date]':
                    case '[object Boolean]':
                        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
                        // millisecond representations. Note that invalid dates with millisecond representations
                        // of `NaN` are not equivalent.
                        return +a == +b;
                        // RegExps are compared by their source patterns and flags.
                    case '[object RegExp]':
                        return a.source == b.source &&
                               a.global == b.global &&
                               a.multiline == b.multiline &&
                               a.ignoreCase == b.ignoreCase;
                }
                if (typeof a != 'object' || typeof b != 'object') return false;
                // Assume equality for cyclic structures. The algorithm for detecting cyclic
                // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
                var length = aStack.length;
                while (length--) {
                    // Linear search. Performance is inversely proportional to the number of
                    // unique nested structures.
                    if (aStack[length] == a) return bStack[length] == b;
                }
                // Add the first object to the stack of traversed objects.
                aStack.push(a);
                bStack.push(b);
                var size = 0, result = true;
                // Recursively compare objects and arrays.
                if (className == '[object Array]') {
                    // Compare array lengths to determine if a deep comparison is necessary.
                    size = a.length;
                    result = size == b.length;
                    if (result) {
                        // Deep compare the contents, ignoring non-numeric properties.
                        while (size--) {
                            if (!(result = eq(a[size], b[size], aStack, bStack))) break;
                        }
                    }
                } else {
                    // Objects with different constructors are not equivalent, but `Object`s
                    // from different frames are.
                    var aCtor = a.constructor, bCtor = b.constructor;
                    if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&
                                             _.isFunction(bCtor) && (bCtor instanceof bCtor))) {
                        return false;
                    }
                    // Deep compare objects.
                    for (var key in a) {
                        if (_.has(a, key)) {
                            // Count the expected number of properties.
                            size++;
                            // Deep compare each member.
                            if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
                        }
                    }
                    // Ensure that both objects contain the same number of properties.
                    if (result) {
                        for (key in b) {
                            if (_.has(b, key) && !(size--)) break;
                        }
                        result = !size;
                    }
                }
                // Remove the first object from the stack of traversed objects.
                aStack.pop();
                bStack.pop();
                return result;
            };

            // Perform a deep comparison to check if two objects are equal.
            _.isEqual = function (a, b) {
                return eq(a, b, [], []);
            };

            // Is a given array, string, or object empty?
            // An "empty" object has no enumerable own-properties.
            _.isEmpty = function (obj) {
                if (obj == null) return true;
                if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
                for (var key in obj) if (_.has(obj, key)) return false;
                return true;
            };

            // Is a given value a DOM element?
            _.isElement = function (obj) {
                return !!(obj && obj.nodeType === 1);
            };

            // Is a given value an array?
            // Delegates to ECMA5's native Array.isArray
            _.isArray = nativeIsArray || function (obj) {
                return toString.call(obj) == '[object Array]';
            };

            // Is a given variable an object?
            _.isObject = function (obj) {
                return obj === Object(obj);
            };

            // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
            each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function (name) {
                _['is' + name] = function (obj) {
                    return toString.call(obj) == '[object ' + name + ']';
                };
            });

            // Define a fallback version of the method in browsers (ahem, IE), where
            // there isn't any inspectable "Arguments" type.
            if (!_.isArguments(arguments)) {
                _.isArguments = function (obj) {
                    return !!(obj && _.has(obj, 'callee'));
                };
            }

            // Optimize `isFunction` if appropriate.
            if (typeof (/./) !== 'function') {
                _.isFunction = function (obj) {
                    return typeof obj === 'function';
                };
            }

            // Is a given object a finite number?
            _.isFinite = function (obj) {
                return isFinite(obj) && !isNaN(parseFloat(obj));
            };

            // Is the given value `NaN`? (NaN is the only number which does not equal itself).
            _.isNaN = function (obj) {
                return _.isNumber(obj) && obj != +obj;
            };

            // Is a given value a boolean?
            _.isBoolean = function (obj) {
                return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
            };

            // Is a given value equal to null?
            _.isNull = function (obj) {
                return obj === null;
            };

            // Is a given variable undefined?
            _.isUndefined = function (obj) {
                return obj === void 0;
            };

            // Shortcut function for checking if an object has a given property directly
            // on itself (in other words, not on a prototype).
            _.has = function (obj, key) {
                return hasOwnProperty.call(obj, key);
            };

            // Utility Functions
            // -----------------

            // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
            // previous owner. Returns a reference to the Underscore object.
            _.noConflict = function () {
                root._ = previousUnderscore;
                return this;
            };

            // Keep the identity function around for default iterators.
            _.identity = function (value) {
                return value;
            };

            // Run a function **n** times.
            _.times = function (n, iterator, context) {
                var accum = Array(n);
                for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
                return accum;
            };

            // Return a random integer between min and max (inclusive).
            _.random = function (min, max) {
                if (max == null) {
                    max = min;
                    min = 0;
                }
                return min + Math.floor(Math.random() * (max - min + 1));
            };

            // List of HTML entities for escaping.
            var entityMap = {
                escape: {
                    '&': '&amp;',
                    '<': '&lt;',
                    '>': '&gt;',
                    '"': '&quot;',
                    "'": '&#x27;',
                    '/': '&#x2F;'
                }
            };
            entityMap.unescape = _.invert(entityMap.escape);

            // Regexes containing the keys and values listed immediately above.
            var entityRegexes = {
                escape: new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
                unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
            };

            // Functions for escaping and unescaping strings to/from HTML interpolation.
            _.each(['escape', 'unescape'], function (method) {
                _[method] = function (string) {
                    if (string == null) return '';
                    return ('' + string).replace(entityRegexes[method], function (match) {
                        return entityMap[method][match];
                    });
                };
            });

            // If the value of the named property is a function then invoke it;
            // otherwise, return it.
            _.result = function (object, property) {
                if (object == null) return null;
                var value = object[property];
                return _.isFunction(value) ? value.call(object) : value;
            };

            // Add your own custom functions to the Underscore object.
            _.mixin = function (obj) {
                each(_.functions(obj), function (name) {
                    var func = _[name] = obj[name];
                    _.prototype[name] = function () {
                        var args = [this._wrapped];
                        push.apply(args, arguments);
                        return result.call(this, func.apply(_, args));
                    };
                });
            };

            // Generate a unique integer id (unique within the entire client session).
            // Useful for temporary DOM ids.
            var idCounter = 0;
            _.uniqueId = function (prefix) {
                var id = ++idCounter + '';
                return prefix ? prefix + id : id;
            };

            // By default, Underscore uses ERB-style template delimiters, change the
            // following template settings to use alternative delimiters.
            _.templateSettings = {
                evaluate: /<%([\s\S]+?)%>/g,
                interpolate: /<%=([\s\S]+?)%>/g,
                escape: /<%-([\s\S]+?)%>/g
            };

            // When customizing `templateSettings`, if you don't want to define an
            // interpolation, evaluation or escaping regex, we need one that is
            // guaranteed not to match.
            var noMatch = /(.)^/;

            // Certain characters need to be escaped so that they can be put into a
            // string literal.
            var escapes = {
                "'": "'",
                '\\': '\\',
                '\r': 'r',
                '\n': 'n',
                '\t': 't',
                '\u2028': 'u2028',
                '\u2029': 'u2029'
            };

            var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;

            // JavaScript micro-templating, similar to John Resig's implementation.
            // Underscore templating handles arbitrary delimiters, preserves whitespace,
            // and correctly escapes quotes within interpolated code.
            _.template = function (text, data, settings) {
                var render;
                settings = _.defaults({}, settings, _.templateSettings);

                // Combine delimiters into one regular expression via alternation.
                var matcher = new RegExp([
                  (settings.escape || noMatch).source,
                  (settings.interpolate || noMatch).source,
                  (settings.evaluate || noMatch).source
                ].join('|') + '|$', 'g');

                // Compile the template source, escaping string literals appropriately.
                var index = 0;
                var source = "__p+='";
                text.replace(matcher, function (match, escape, interpolate, evaluate, offset) {
                    source += text.slice(index, offset)
                      .replace(escaper, function (match) { return '\\' + escapes[match]; });

                    if (escape) {
                        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
                    }
                    if (interpolate) {
                        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
                    }
                    if (evaluate) {
                        source += "';\n" + evaluate + "\n__p+='";
                    }
                    index = offset + match.length;
                    return match;
                });
                source += "';\n";

                // If a variable is not specified, place data values in local scope.
                if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

                source = "var __t,__p='',__j=Array.prototype.join," +
                  "print=function(){__p+=__j.call(arguments,'');};\n" +
                  source + "return __p;\n";

                try {
                    render = new Function(settings.variable || 'obj', '_', source);
                } catch (e) {
                    e.source = source;
                    throw e;
                }

                if (data) return render(data, _);
                var template = function (data) {
                    return render.call(this, data, _);
                };

                // Provide the compiled function source as a convenience for precompilation.
                template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';

                return template;
            };

            // Add a "chain" function, which will delegate to the wrapper.
            _.chain = function (obj) {
                return _(obj).chain();
            };

            // OOP
            // ---------------
            // If Underscore is called as a function, it returns a wrapped object that
            // can be used OO-style. This wrapper holds altered versions of all the
            // underscore functions. Wrapped objects may be chained.

            // Helper function to continue chaining intermediate results.
            var result = function (obj) {
                return this._chain ? _(obj).chain() : obj;
            };

            // Add all of the Underscore functions to the wrapper object.
            _.mixin(_);

            // Add all mutator Array functions to the wrapper.
            each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function (name) {
                var method = ArrayProto[name];
                _.prototype[name] = function () {
                    var obj = this._wrapped;
                    method.apply(obj, arguments);
                    if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
                    return result.call(this, obj);
                };
            });

            // Add all accessor Array functions to the wrapper.
            each(['concat', 'join', 'slice'], function (name) {
                var method = ArrayProto[name];
                _.prototype[name] = function () {
                    return result.call(this, method.apply(this._wrapped, arguments));
                };
            });

            _.extend(_.prototype, {

                // Start chaining a wrapped Underscore object.
                chain: function () {
                    this._chain = true;
                    return this;
                },

                // Extracts the result from a wrapped and chained object.
                value: function () {
                    return this._wrapped;
                }

            });

        }).call(this);

    }, {}], 8: [function (require, module, exports) {
        /*!
         * The buffer module from node.js, for the browser.
         *
         * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
         * @license  MIT
         */

        var base64 = require('base64-js')
        var ieee754 = require('ieee754')

        exports.Buffer = Buffer
        exports.SlowBuffer = Buffer
        exports.INSPECT_MAX_BYTES = 50
        Buffer.poolSize = 8192

        /**
         * If `TYPED_ARRAY_SUPPORT`:
         *   === true    Use Uint8Array implementation (fastest)
         *   === false   Use Object implementation (most compatible, even IE6)
         *
         * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
         * Opera 11.6+, iOS 4.2+.
         *
         * Note:
         *
         * - Implementation must support adding new properties to `Uint8Array` instances.
         *   Firefox 4-29 lacked support, fixed in Firefox 30+.
         *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
         *
         *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
         *
         *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
         *    incorrect length in some situations.
         *
         * We detect these buggy browsers and set `TYPED_ARRAY_SUPPORT` to `false` so they will
         * get the Object implementation, which is slower but will work correctly.
         */
        var TYPED_ARRAY_SUPPORT = (function () {
            try {
                var buf = new ArrayBuffer(0)
                var arr = new Uint8Array(buf)
                arr.foo = function () { return 42 }
                return 42 === arr.foo() && // typed array instances can be augmented
                    typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
                    new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
            } catch (e) {
                return false
            }
        })()

        /**
         * Class: Buffer
         * =============
         *
         * The Buffer constructor returns instances of `Uint8Array` that are augmented
         * with function properties for all the node `Buffer` API functions. We use
         * `Uint8Array` so that square bracket notation works as expected -- it returns
         * a single octet.
         *
         * By augmenting the instances, we can avoid modifying the `Uint8Array`
         * prototype.
         */
        function Buffer(subject, encoding, noZero) {
            if (!(this instanceof Buffer))
                return new Buffer(subject, encoding, noZero)

            var type = typeof subject

            // Find the length
            var length
            if (type === 'number')
                length = subject > 0 ? subject >>> 0 : 0
            else if (type === 'string') {
                if (encoding === 'base64')
                    subject = base64clean(subject)
                length = Buffer.byteLength(subject, encoding)
            } else if (type === 'object' && subject !== null) { // assume object is array-like
                if (subject.type === 'Buffer' && isArray(subject.data))
                    subject = subject.data
                length = +subject.length > 0 ? Math.floor(+subject.length) : 0
            } else
                throw new Error('First argument needs to be a number, array or string.')

            var buf
            if (TYPED_ARRAY_SUPPORT) {
                // Preferred: Return an augmented `Uint8Array` instance for best performance
                buf = Buffer._augment(new Uint8Array(length))
            } else {
                // Fallback: Return THIS instance of Buffer (created by `new`)
                buf = this
                buf.length = length
                buf._isBuffer = true
            }

            var i
            if (TYPED_ARRAY_SUPPORT && typeof subject.byteLength === 'number') {
                // Speed optimization -- use set if we're copying from a typed array
                buf._set(subject)
            } else if (isArrayish(subject)) {
                // Treat array-ish objects as a byte array
                if (Buffer.isBuffer(subject)) {
                    for (i = 0; i < length; i++)
                        buf[i] = subject.readUInt8(i)
                } else {
                    for (i = 0; i < length; i++)
                        buf[i] = ((subject[i] % 256) + 256) % 256
                }
            } else if (type === 'string') {
                buf.write(subject, 0, encoding)
            } else if (type === 'number' && !TYPED_ARRAY_SUPPORT && !noZero) {
                for (i = 0; i < length; i++) {
                    buf[i] = 0
                }
            }

            return buf
        }

        // STATIC METHODS
        // ==============

        Buffer.isEncoding = function (encoding) {
            switch (String(encoding).toLowerCase()) {
                case 'hex':
                case 'utf8':
                case 'utf-8':
                case 'ascii':
                case 'binary':
                case 'base64':
                case 'raw':
                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                    return true
                default:
                    return false
            }
        }

        Buffer.isBuffer = function (b) {
            return !!(b != null && b._isBuffer)
        }

        Buffer.byteLength = function (str, encoding) {
            var ret
            str = str.toString()
            switch (encoding || 'utf8') {
                case 'hex':
                    ret = str.length / 2
                    break
                case 'utf8':
                case 'utf-8':
                    ret = utf8ToBytes(str).length
                    break
                case 'ascii':
                case 'binary':
                case 'raw':
                    ret = str.length
                    break
                case 'base64':
                    ret = base64ToBytes(str).length
                    break
                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                    ret = str.length * 2
                    break
                default:
                    throw new Error('Unknown encoding')
            }
            return ret
        }

        Buffer.concat = function (list, totalLength) {
            assert(isArray(list), 'Usage: Buffer.concat(list[, length])')

            if (list.length === 0) {
                return new Buffer(0)
            } else if (list.length === 1) {
                return list[0]
            }

            var i
            if (totalLength === undefined) {
                totalLength = 0
                for (i = 0; i < list.length; i++) {
                    totalLength += list[i].length
                }
            }

            var buf = new Buffer(totalLength)
            var pos = 0
            for (i = 0; i < list.length; i++) {
                var item = list[i]
                item.copy(buf, pos)
                pos += item.length
            }
            return buf
        }

        Buffer.compare = function (a, b) {
            assert(Buffer.isBuffer(a) && Buffer.isBuffer(b), 'Arguments must be Buffers')
            var x = a.length
            var y = b.length
            for (var i = 0, len = Math.min(x, y) ; i < len && a[i] === b[i]; i++) { }
            if (i !== len) {
                x = a[i]
                y = b[i]
            }
            if (x < y) {
                return -1
            }
            if (y < x) {
                return 1
            }
            return 0
        }

        // BUFFER INSTANCE METHODS
        // =======================

        function hexWrite(buf, string, offset, length) {
            offset = Number(offset) || 0
            var remaining = buf.length - offset
            if (!length) {
                length = remaining
            } else {
                length = Number(length)
                if (length > remaining) {
                    length = remaining
                }
            }

            // must be an even number of digits
            var strLen = string.length
            assert(strLen % 2 === 0, 'Invalid hex string')

            if (length > strLen / 2) {
                length = strLen / 2
            }
            for (var i = 0; i < length; i++) {
                var byte = parseInt(string.substr(i * 2, 2), 16)
                assert(!isNaN(byte), 'Invalid hex string')
                buf[offset + i] = byte
            }
            return i
        }

        function utf8Write(buf, string, offset, length) {
            var charsWritten = blitBuffer(utf8ToBytes(string), buf, offset, length)
            return charsWritten
        }

        function asciiWrite(buf, string, offset, length) {
            var charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length)
            return charsWritten
        }

        function binaryWrite(buf, string, offset, length) {
            return asciiWrite(buf, string, offset, length)
        }

        function base64Write(buf, string, offset, length) {
            var charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length)
            return charsWritten
        }

        function utf16leWrite(buf, string, offset, length) {
            var charsWritten = blitBuffer(utf16leToBytes(string), buf, offset, length)
            return charsWritten
        }

        Buffer.prototype.write = function (string, offset, length, encoding) {
            // Support both (string, offset, length, encoding)
            // and the legacy (string, encoding, offset, length)
            if (isFinite(offset)) {
                if (!isFinite(length)) {
                    encoding = length
                    length = undefined
                }
            } else {  // legacy
                var swap = encoding
                encoding = offset
                offset = length
                length = swap
            }

            offset = Number(offset) || 0
            var remaining = this.length - offset
            if (!length) {
                length = remaining
            } else {
                length = Number(length)
                if (length > remaining) {
                    length = remaining
                }
            }
            encoding = String(encoding || 'utf8').toLowerCase()

            var ret
            switch (encoding) {
                case 'hex':
                    ret = hexWrite(this, string, offset, length)
                    break
                case 'utf8':
                case 'utf-8':
                    ret = utf8Write(this, string, offset, length)
                    break
                case 'ascii':
                    ret = asciiWrite(this, string, offset, length)
                    break
                case 'binary':
                    ret = binaryWrite(this, string, offset, length)
                    break
                case 'base64':
                    ret = base64Write(this, string, offset, length)
                    break
                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                    ret = utf16leWrite(this, string, offset, length)
                    break
                default:
                    throw new Error('Unknown encoding')
            }
            return ret
        }

        Buffer.prototype.toString = function (encoding, start, end) {
            var self = this

            encoding = String(encoding || 'utf8').toLowerCase()
            start = Number(start) || 0
            end = (end === undefined) ? self.length : Number(end)

            // Fastpath empty strings
            if (end === start)
                return ''

            var ret
            switch (encoding) {
                case 'hex':
                    ret = hexSlice(self, start, end)
                    break
                case 'utf8':
                case 'utf-8':
                    ret = utf8Slice(self, start, end)
                    break
                case 'ascii':
                    ret = asciiSlice(self, start, end)
                    break
                case 'binary':
                    ret = binarySlice(self, start, end)
                    break
                case 'base64':
                    ret = base64Slice(self, start, end)
                    break
                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                    ret = utf16leSlice(self, start, end)
                    break
                default:
                    throw new Error('Unknown encoding')
            }
            return ret
        }

        Buffer.prototype.toJSON = function () {
            return {
                type: 'Buffer',
                data: Array.prototype.slice.call(this._arr || this, 0)
            }
        }

        Buffer.prototype.equals = function (b) {
            assert(Buffer.isBuffer(b), 'Argument must be a Buffer')
            return Buffer.compare(this, b) === 0
        }

        Buffer.prototype.compare = function (b) {
            assert(Buffer.isBuffer(b), 'Argument must be a Buffer')
            return Buffer.compare(this, b)
        }

        // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
        Buffer.prototype.copy = function (target, target_start, start, end) {
            var source = this

            if (!start) start = 0
            if (!end && end !== 0) end = this.length
            if (!target_start) target_start = 0

            // Copy 0 bytes; we're done
            if (end === start) return
            if (target.length === 0 || source.length === 0) return

            // Fatal error conditions
            assert(end >= start, 'sourceEnd < sourceStart')
            assert(target_start >= 0 && target_start < target.length,
                'targetStart out of bounds')
            assert(start >= 0 && start < source.length, 'sourceStart out of bounds')
            assert(end >= 0 && end <= source.length, 'sourceEnd out of bounds')

            // Are we oob?
            if (end > this.length)
                end = this.length
            if (target.length - target_start < end - start)
                end = target.length - target_start + start

            var len = end - start

            if (len < 100 || !TYPED_ARRAY_SUPPORT) {
                for (var i = 0; i < len; i++) {
                    target[i + target_start] = this[i + start]
                }
            } else {
                target._set(this.subarray(start, start + len), target_start)
            }
        }

        function base64Slice(buf, start, end) {
            if (start === 0 && end === buf.length) {
                return base64.fromByteArray(buf)
            } else {
                return base64.fromByteArray(buf.slice(start, end))
            }
        }

        function utf8Slice(buf, start, end) {
            var res = ''
            var tmp = ''
            end = Math.min(buf.length, end)

            for (var i = start; i < end; i++) {
                if (buf[i] <= 0x7F) {
                    res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
                    tmp = ''
                } else {
                    tmp += '%' + buf[i].toString(16)
                }
            }

            return res + decodeUtf8Char(tmp)
        }

        function asciiSlice(buf, start, end) {
            var ret = ''
            end = Math.min(buf.length, end)

            for (var i = start; i < end; i++) {
                ret += String.fromCharCode(buf[i])
            }
            return ret
        }

        function binarySlice(buf, start, end) {
            return asciiSlice(buf, start, end)
        }

        function hexSlice(buf, start, end) {
            var len = buf.length

            if (!start || start < 0) start = 0
            if (!end || end < 0 || end > len) end = len

            var out = ''
            for (var i = start; i < end; i++) {
                out += toHex(buf[i])
            }
            return out
        }

        function utf16leSlice(buf, start, end) {
            var bytes = buf.slice(start, end)
            var res = ''
            for (var i = 0; i < bytes.length; i += 2) {
                res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
            }
            return res
        }

        Buffer.prototype.slice = function (start, end) {
            var len = this.length
            start = ~~start
            end = end === undefined ? len : ~~end

            if (start < 0) {
                start += len;
                if (start < 0)
                    start = 0
            } else if (start > len) {
                start = len
            }

            if (end < 0) {
                end += len
                if (end < 0)
                    end = 0
            } else if (end > len) {
                end = len
            }

            if (end < start)
                end = start

            if (TYPED_ARRAY_SUPPORT) {
                return Buffer._augment(this.subarray(start, end))
            } else {
                var sliceLen = end - start
                var newBuf = new Buffer(sliceLen, undefined, true)
                for (var i = 0; i < sliceLen; i++) {
                    newBuf[i] = this[i + start]
                }
                return newBuf
            }
        }

        // `get` will be removed in Node 0.13+
        Buffer.prototype.get = function (offset) {
            console.log('.get() is deprecated. Access using array indexes instead.')
            return this.readUInt8(offset)
        }

        // `set` will be removed in Node 0.13+
        Buffer.prototype.set = function (v, offset) {
            console.log('.set() is deprecated. Access using array indexes instead.')
            return this.writeUInt8(v, offset)
        }

        Buffer.prototype.readUInt8 = function (offset, noAssert) {
            if (!noAssert) {
                assert(offset !== undefined && offset !== null, 'missing offset')
                assert(offset < this.length, 'Trying to read beyond buffer length')
            }

            if (offset >= this.length)
                return

            return this[offset]
        }

        function readUInt16(buf, offset, littleEndian, noAssert) {
            if (!noAssert) {
                assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
                assert(offset !== undefined && offset !== null, 'missing offset')
                assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
            }

            var len = buf.length
            if (offset >= len)
                return

            var val
            if (littleEndian) {
                val = buf[offset]
                if (offset + 1 < len)
                    val |= buf[offset + 1] << 8
            } else {
                val = buf[offset] << 8
                if (offset + 1 < len)
                    val |= buf[offset + 1]
            }
            return val
        }

        Buffer.prototype.readUInt16LE = function (offset, noAssert) {
            return readUInt16(this, offset, true, noAssert)
        }

        Buffer.prototype.readUInt16BE = function (offset, noAssert) {
            return readUInt16(this, offset, false, noAssert)
        }

        function readUInt32(buf, offset, littleEndian, noAssert) {
            if (!noAssert) {
                assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
                assert(offset !== undefined && offset !== null, 'missing offset')
                assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
            }

            var len = buf.length
            if (offset >= len)
                return

            var val
            if (littleEndian) {
                if (offset + 2 < len)
                    val = buf[offset + 2] << 16
                if (offset + 1 < len)
                    val |= buf[offset + 1] << 8
                val |= buf[offset]
                if (offset + 3 < len)
                    val = val + (buf[offset + 3] << 24 >>> 0)
            } else {
                if (offset + 1 < len)
                    val = buf[offset + 1] << 16
                if (offset + 2 < len)
                    val |= buf[offset + 2] << 8
                if (offset + 3 < len)
                    val |= buf[offset + 3]
                val = val + (buf[offset] << 24 >>> 0)
            }
            return val
        }

        Buffer.prototype.readUInt32LE = function (offset, noAssert) {
            return readUInt32(this, offset, true, noAssert)
        }

        Buffer.prototype.readUInt32BE = function (offset, noAssert) {
            return readUInt32(this, offset, false, noAssert)
        }

        Buffer.prototype.readInt8 = function (offset, noAssert) {
            if (!noAssert) {
                assert(offset !== undefined && offset !== null,
                    'missing offset')
                assert(offset < this.length, 'Trying to read beyond buffer length')
            }

            if (offset >= this.length)
                return

            var neg = this[offset] & 0x80
            if (neg)
                return (0xff - this[offset] + 1) * -1
            else
                return this[offset]
        }

        function readInt16(buf, offset, littleEndian, noAssert) {
            if (!noAssert) {
                assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
                assert(offset !== undefined && offset !== null, 'missing offset')
                assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
            }

            var len = buf.length
            if (offset >= len)
                return

            var val = readUInt16(buf, offset, littleEndian, true)
            var neg = val & 0x8000
            if (neg)
                return (0xffff - val + 1) * -1
            else
                return val
        }

        Buffer.prototype.readInt16LE = function (offset, noAssert) {
            return readInt16(this, offset, true, noAssert)
        }

        Buffer.prototype.readInt16BE = function (offset, noAssert) {
            return readInt16(this, offset, false, noAssert)
        }

        function readInt32(buf, offset, littleEndian, noAssert) {
            if (!noAssert) {
                assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
                assert(offset !== undefined && offset !== null, 'missing offset')
                assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
            }

            var len = buf.length
            if (offset >= len)
                return

            var val = readUInt32(buf, offset, littleEndian, true)
            var neg = val & 0x80000000
            if (neg)
                return (0xffffffff - val + 1) * -1
            else
                return val
        }

        Buffer.prototype.readInt32LE = function (offset, noAssert) {
            return readInt32(this, offset, true, noAssert)
        }

        Buffer.prototype.readInt32BE = function (offset, noAssert) {
            return readInt32(this, offset, false, noAssert)
        }

        function readFloat(buf, offset, littleEndian, noAssert) {
            if (!noAssert) {
                assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
                assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
            }

            return ieee754.read(buf, offset, littleEndian, 23, 4)
        }

        Buffer.prototype.readFloatLE = function (offset, noAssert) {
            return readFloat(this, offset, true, noAssert)
        }

        Buffer.prototype.readFloatBE = function (offset, noAssert) {
            return readFloat(this, offset, false, noAssert)
        }

        function readDouble(buf, offset, littleEndian, noAssert) {
            if (!noAssert) {
                assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
                assert(offset + 7 < buf.length, 'Trying to read beyond buffer length')
            }

            return ieee754.read(buf, offset, littleEndian, 52, 8)
        }

        Buffer.prototype.readDoubleLE = function (offset, noAssert) {
            return readDouble(this, offset, true, noAssert)
        }

        Buffer.prototype.readDoubleBE = function (offset, noAssert) {
            return readDouble(this, offset, false, noAssert)
        }

        Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
            if (!noAssert) {
                assert(value !== undefined && value !== null, 'missing value')
                assert(offset !== undefined && offset !== null, 'missing offset')
                assert(offset < this.length, 'trying to write beyond buffer length')
                verifuint(value, 0xff)
            }

            if (offset >= this.length) return

            this[offset] = value
            return offset + 1
        }

        function writeUInt16(buf, value, offset, littleEndian, noAssert) {
            if (!noAssert) {
                assert(value !== undefined && value !== null, 'missing value')
                assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
                assert(offset !== undefined && offset !== null, 'missing offset')
                assert(offset + 1 < buf.length, 'trying to write beyond buffer length')
                verifuint(value, 0xffff)
            }

            var len = buf.length
            if (offset >= len)
                return

            for (var i = 0, j = Math.min(len - offset, 2) ; i < j; i++) {
                buf[offset + i] =
                    (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
                        (littleEndian ? i : 1 - i) * 8
            }
            return offset + 2
        }

        Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
            return writeUInt16(this, value, offset, true, noAssert)
        }

        Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
            return writeUInt16(this, value, offset, false, noAssert)
        }

        function writeUInt32(buf, value, offset, littleEndian, noAssert) {
            if (!noAssert) {
                assert(value !== undefined && value !== null, 'missing value')
                assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
                assert(offset !== undefined && offset !== null, 'missing offset')
                assert(offset + 3 < buf.length, 'trying to write beyond buffer length')
                verifuint(value, 0xffffffff)
            }

            var len = buf.length
            if (offset >= len)
                return

            for (var i = 0, j = Math.min(len - offset, 4) ; i < j; i++) {
                buf[offset + i] =
                    (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
            }
            return offset + 4
        }

        Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
            return writeUInt32(this, value, offset, true, noAssert)
        }

        Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
            return writeUInt32(this, value, offset, false, noAssert)
        }

        Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
            if (!noAssert) {
                assert(value !== undefined && value !== null, 'missing value')
                assert(offset !== undefined && offset !== null, 'missing offset')
                assert(offset < this.length, 'Trying to write beyond buffer length')
                verifsint(value, 0x7f, -0x80)
            }

            if (offset >= this.length)
                return

            if (value >= 0)
                this.writeUInt8(value, offset, noAssert)
            else
                this.writeUInt8(0xff + value + 1, offset, noAssert)
            return offset + 1
        }

        function writeInt16(buf, value, offset, littleEndian, noAssert) {
            if (!noAssert) {
                assert(value !== undefined && value !== null, 'missing value')
                assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
                assert(offset !== undefined && offset !== null, 'missing offset')
                assert(offset + 1 < buf.length, 'Trying to write beyond buffer length')
                verifsint(value, 0x7fff, -0x8000)
            }

            var len = buf.length
            if (offset >= len)
                return

            if (value >= 0)
                writeUInt16(buf, value, offset, littleEndian, noAssert)
            else
                writeUInt16(buf, 0xffff + value + 1, offset, littleEndian, noAssert)
            return offset + 2
        }

        Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
            return writeInt16(this, value, offset, true, noAssert)
        }

        Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
            return writeInt16(this, value, offset, false, noAssert)
        }

        function writeInt32(buf, value, offset, littleEndian, noAssert) {
            if (!noAssert) {
                assert(value !== undefined && value !== null, 'missing value')
                assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
                assert(offset !== undefined && offset !== null, 'missing offset')
                assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
                verifsint(value, 0x7fffffff, -0x80000000)
            }

            var len = buf.length
            if (offset >= len)
                return

            if (value >= 0)
                writeUInt32(buf, value, offset, littleEndian, noAssert)
            else
                writeUInt32(buf, 0xffffffff + value + 1, offset, littleEndian, noAssert)
            return offset + 4
        }

        Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
            return writeInt32(this, value, offset, true, noAssert)
        }

        Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
            return writeInt32(this, value, offset, false, noAssert)
        }

        function writeFloat(buf, value, offset, littleEndian, noAssert) {
            if (!noAssert) {
                assert(value !== undefined && value !== null, 'missing value')
                assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
                assert(offset !== undefined && offset !== null, 'missing offset')
                assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
                verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38)
            }

            var len = buf.length
            if (offset >= len)
                return

            ieee754.write(buf, value, offset, littleEndian, 23, 4)
            return offset + 4
        }

        Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
            return writeFloat(this, value, offset, true, noAssert)
        }

        Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
            return writeFloat(this, value, offset, false, noAssert)
        }

        function writeDouble(buf, value, offset, littleEndian, noAssert) {
            if (!noAssert) {
                assert(value !== undefined && value !== null, 'missing value')
                assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
                assert(offset !== undefined && offset !== null, 'missing offset')
                assert(offset + 7 < buf.length,
                    'Trying to write beyond buffer length')
                verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308)
            }

            var len = buf.length
            if (offset >= len)
                return

            ieee754.write(buf, value, offset, littleEndian, 52, 8)
            return offset + 8
        }

        Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
            return writeDouble(this, value, offset, true, noAssert)
        }

        Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
            return writeDouble(this, value, offset, false, noAssert)
        }

        // fill(value, start=0, end=buffer.length)
        Buffer.prototype.fill = function (value, start, end) {
            if (!value) value = 0
            if (!start) start = 0
            if (!end) end = this.length

            assert(end >= start, 'end < start')

            // Fill 0 bytes; we're done
            if (end === start) return
            if (this.length === 0) return

            assert(start >= 0 && start < this.length, 'start out of bounds')
            assert(end >= 0 && end <= this.length, 'end out of bounds')

            var i
            if (typeof value === 'number') {
                for (i = start; i < end; i++) {
                    this[i] = value
                }
            } else {
                var bytes = utf8ToBytes(value.toString())
                var len = bytes.length
                for (i = start; i < end; i++) {
                    this[i] = bytes[i % len]
                }
            }

            return this
        }

        Buffer.prototype.inspect = function () {
            var out = []
            var len = this.length
            for (var i = 0; i < len; i++) {
                out[i] = toHex(this[i])
                if (i === exports.INSPECT_MAX_BYTES) {
                    out[i + 1] = '...'
                    break
                }
            }
            return '<Buffer ' + out.join(' ') + '>'
        }

        /**
         * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
         * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
         */
        Buffer.prototype.toArrayBuffer = function () {
            if (typeof Uint8Array !== 'undefined') {
                if (TYPED_ARRAY_SUPPORT) {
                    return (new Buffer(this)).buffer
                } else {
                    var buf = new Uint8Array(this.length)
                    for (var i = 0, len = buf.length; i < len; i += 1) {
                        buf[i] = this[i]
                    }
                    return buf.buffer
                }
            } else {
                throw new Error('Buffer.toArrayBuffer not supported in this browser')
            }
        }

        // HELPER FUNCTIONS
        // ================

        var BP = Buffer.prototype

        /**
         * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
         */
        Buffer._augment = function (arr) {
            arr._isBuffer = true

            // save reference to original Uint8Array get/set methods before overwriting
            arr._get = arr.get
            arr._set = arr.set

            // deprecated, will be removed in node 0.13+
            arr.get = BP.get
            arr.set = BP.set

            arr.write = BP.write
            arr.toString = BP.toString
            arr.toLocaleString = BP.toString
            arr.toJSON = BP.toJSON
            arr.equals = BP.equals
            arr.compare = BP.compare
            arr.copy = BP.copy
            arr.slice = BP.slice
            arr.readUInt8 = BP.readUInt8
            arr.readUInt16LE = BP.readUInt16LE
            arr.readUInt16BE = BP.readUInt16BE
            arr.readUInt32LE = BP.readUInt32LE
            arr.readUInt32BE = BP.readUInt32BE
            arr.readInt8 = BP.readInt8
            arr.readInt16LE = BP.readInt16LE
            arr.readInt16BE = BP.readInt16BE
            arr.readInt32LE = BP.readInt32LE
            arr.readInt32BE = BP.readInt32BE
            arr.readFloatLE = BP.readFloatLE
            arr.readFloatBE = BP.readFloatBE
            arr.readDoubleLE = BP.readDoubleLE
            arr.readDoubleBE = BP.readDoubleBE
            arr.writeUInt8 = BP.writeUInt8
            arr.writeUInt16LE = BP.writeUInt16LE
            arr.writeUInt16BE = BP.writeUInt16BE
            arr.writeUInt32LE = BP.writeUInt32LE
            arr.writeUInt32BE = BP.writeUInt32BE
            arr.writeInt8 = BP.writeInt8
            arr.writeInt16LE = BP.writeInt16LE
            arr.writeInt16BE = BP.writeInt16BE
            arr.writeInt32LE = BP.writeInt32LE
            arr.writeInt32BE = BP.writeInt32BE
            arr.writeFloatLE = BP.writeFloatLE
            arr.writeFloatBE = BP.writeFloatBE
            arr.writeDoubleLE = BP.writeDoubleLE
            arr.writeDoubleBE = BP.writeDoubleBE
            arr.fill = BP.fill
            arr.inspect = BP.inspect
            arr.toArrayBuffer = BP.toArrayBuffer

            return arr
        }

        var INVALID_BASE64_RE = /[^+\/0-9A-z]/g

        function base64clean(str) {
            // Node strips out invalid characters like \n and \t from the string, base64-js does not
            str = stringtrim(str).replace(INVALID_BASE64_RE, '')
            // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
            while (str.length % 4 !== 0) {
                str = str + '='
            }
            return str
        }

        function stringtrim(str) {
            if (str.trim) return str.trim()
            return str.replace(/^\s+|\s+$/g, '')
        }

        function isArray(subject) {
            return (Array.isArray || function (subject) {
                return Object.prototype.toString.call(subject) === '[object Array]'
            })(subject)
        }

        function isArrayish(subject) {
            return isArray(subject) || Buffer.isBuffer(subject) ||
                subject && typeof subject === 'object' &&
                typeof subject.length === 'number'
        }

        function toHex(n) {
            if (n < 16) return '0' + n.toString(16)
            return n.toString(16)
        }

        function utf8ToBytes(str) {
            var byteArray = []
            for (var i = 0; i < str.length; i++) {
                var b = str.charCodeAt(i)
                if (b <= 0x7F) {
                    byteArray.push(b)
                } else {
                    var start = i
                    if (b >= 0xD800 && b <= 0xDFFF) i++
                    var h = encodeURIComponent(str.slice(start, i + 1)).substr(1).split('%')
                    for (var j = 0; j < h.length; j++) {
                        byteArray.push(parseInt(h[j], 16))
                    }
                }
            }
            return byteArray
        }

        function asciiToBytes(str) {
            var byteArray = []
            for (var i = 0; i < str.length; i++) {
                // Node's code seems to be doing this and not & 0x7F..
                byteArray.push(str.charCodeAt(i) & 0xFF)
            }
            return byteArray
        }

        function utf16leToBytes(str) {
            var c, hi, lo
            var byteArray = []
            for (var i = 0; i < str.length; i++) {
                c = str.charCodeAt(i)
                hi = c >> 8
                lo = c % 256
                byteArray.push(lo)
                byteArray.push(hi)
            }

            return byteArray
        }

        function base64ToBytes(str) {
            return base64.toByteArray(str)
        }

        function blitBuffer(src, dst, offset, length) {
            for (var i = 0; i < length; i++) {
                if ((i + offset >= dst.length) || (i >= src.length))
                    break
                dst[i + offset] = src[i]
            }
            return i
        }

        function decodeUtf8Char(str) {
            try {
                return decodeURIComponent(str)
            } catch (err) {
                return String.fromCharCode(0xFFFD) // UTF 8 invalid char
            }
        }

        /*
         * We have to make sure that the value is a valid integer. This means that it
         * is non-negative. It has no fractional component and that it does not
         * exceed the maximum allowed value.
         */
        function verifuint(value, max) {
            assert(typeof value === 'number', 'cannot write a non-number as a number')
            assert(value >= 0, 'specified a negative value for writing an unsigned value')
            assert(value <= max, 'value is larger than maximum value for type')
            assert(Math.floor(value) === value, 'value has a fractional component')
        }

        function verifsint(value, max, min) {
            assert(typeof value === 'number', 'cannot write a non-number as a number')
            assert(value <= max, 'value larger than maximum allowed value')
            assert(value >= min, 'value smaller than minimum allowed value')
            assert(Math.floor(value) === value, 'value has a fractional component')
        }

        function verifIEEE754(value, max, min) {
            assert(typeof value === 'number', 'cannot write a non-number as a number')
            assert(value <= max, 'value larger than maximum allowed value')
            assert(value >= min, 'value smaller than minimum allowed value')
        }

        function assert(test, message) {
            if (!test) throw new Error(message || 'Failed assertion')
        }

    }, { "base64-js": 9, "ieee754": 10 }], 9: [function (require, module, exports) {
        var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

        ; (function (exports) {
            'use strict';

            var Arr = (typeof Uint8Array !== 'undefined')
              ? Uint8Array
              : Array

            var PLUS = '+'.charCodeAt(0)
            var SLASH = '/'.charCodeAt(0)
            var NUMBER = '0'.charCodeAt(0)
            var LOWER = 'a'.charCodeAt(0)
            var UPPER = 'A'.charCodeAt(0)

            function decode(elt) {
                var code = elt.charCodeAt(0)
                if (code === PLUS)
                    return 62 // '+'
                if (code === SLASH)
                    return 63 // '/'
                if (code < NUMBER)
                    return -1 //no match
                if (code < NUMBER + 10)
                    return code - NUMBER + 26 + 26
                if (code < UPPER + 26)
                    return code - UPPER
                if (code < LOWER + 26)
                    return code - LOWER + 26
            }

            function b64ToByteArray(b64) {
                var i, j, l, tmp, placeHolders, arr

                if (b64.length % 4 > 0) {
                    throw new Error('Invalid string. Length must be a multiple of 4')
                }

                // the number of equal signs (place holders)
                // if there are two placeholders, than the two characters before it
                // represent one byte
                // if there is only one, then the three characters before it represent 2 bytes
                // this is just a cheap hack to not do indexOf twice
                var len = b64.length
                placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

                // base64 is 4/3 + up to two characters of the original data
                arr = new Arr(b64.length * 3 / 4 - placeHolders)

                // if there are placeholders, only get up to the last complete 4 chars
                l = placeHolders > 0 ? b64.length - 4 : b64.length

                var L = 0

                function push(v) {
                    arr[L++] = v
                }

                for (i = 0, j = 0; i < l; i += 4, j += 3) {
                    tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
                    push((tmp & 0xFF0000) >> 16)
                    push((tmp & 0xFF00) >> 8)
                    push(tmp & 0xFF)
                }

                if (placeHolders === 2) {
                    tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
                    push(tmp & 0xFF)
                } else if (placeHolders === 1) {
                    tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
                    push((tmp >> 8) & 0xFF)
                    push(tmp & 0xFF)
                }

                return arr
            }

            function uint8ToBase64(uint8) {
                var i,
                    extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
                    output = "",
                    temp, length

                function encode(num) {
                    return lookup.charAt(num)
                }

                function tripletToBase64(num) {
                    return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
                }

                // go through the array every three bytes, we'll deal with trailing stuff later
                for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
                    temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
                    output += tripletToBase64(temp)
                }

                // pad the end with zeros, but make sure to not forget the extra bytes
                switch (extraBytes) {
                    case 1:
                        temp = uint8[uint8.length - 1]
                        output += encode(temp >> 2)
                        output += encode((temp << 4) & 0x3F)
                        output += '=='
                        break
                    case 2:
                        temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
                        output += encode(temp >> 10)
                        output += encode((temp >> 4) & 0x3F)
                        output += encode((temp << 2) & 0x3F)
                        output += '='
                        break
                }

                return output
            }

            exports.toByteArray = b64ToByteArray
            exports.fromByteArray = uint8ToBase64
        }(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

    }, {}], 10: [function (require, module, exports) {
        exports.read = function (buffer, offset, isLE, mLen, nBytes) {
            var e, m,
                eLen = nBytes * 8 - mLen - 1,
                eMax = (1 << eLen) - 1,
                eBias = eMax >> 1,
                nBits = -7,
                i = isLE ? (nBytes - 1) : 0,
                d = isLE ? -1 : 1,
                s = buffer[offset + i];

            i += d;

            e = s & ((1 << (-nBits)) - 1);
            s >>= (-nBits);
            nBits += eLen;
            for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

            m = e & ((1 << (-nBits)) - 1);
            e >>= (-nBits);
            nBits += mLen;
            for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

            if (e === 0) {
                e = 1 - eBias;
            } else if (e === eMax) {
                return m ? NaN : ((s ? -1 : 1) * Infinity);
            } else {
                m = m + Math.pow(2, mLen);
                e = e - eBias;
            }
            return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
        };

        exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
            var e, m, c,
                eLen = nBytes * 8 - mLen - 1,
                eMax = (1 << eLen) - 1,
                eBias = eMax >> 1,
                rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
                i = isLE ? 0 : (nBytes - 1),
                d = isLE ? 1 : -1,
                s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

            value = Math.abs(value);

            if (isNaN(value) || value === Infinity) {
                m = isNaN(value) ? 1 : 0;
                e = eMax;
            } else {
                e = Math.floor(Math.log(value) / Math.LN2);
                if (value * (c = Math.pow(2, -e)) < 1) {
                    e--;
                    c *= 2;
                }
                if (e + eBias >= 1) {
                    value += rt / c;
                } else {
                    value += rt * Math.pow(2, 1 - eBias);
                }
                if (value * c >= 2) {
                    e++;
                    c /= 2;
                }

                if (e + eBias >= eMax) {
                    m = 0;
                    e = eMax;
                } else if (e + eBias >= 1) {
                    m = (value * c - 1) * Math.pow(2, mLen);
                    e = e + eBias;
                } else {
                    m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                    e = 0;
                }
            }

            for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

            e = (e << mLen) | m;
            eLen += mLen;
            for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

            buffer[offset + i - d] |= s * 128;
        };

    }, {}], 11: [function (require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.

        function EventEmitter() {
            this._events = this._events || {};
            this._maxListeners = this._maxListeners || undefined;
        }
        module.exports = EventEmitter;

        // Backwards-compat with node 0.10.x
        EventEmitter.EventEmitter = EventEmitter;

        EventEmitter.prototype._events = undefined;
        EventEmitter.prototype._maxListeners = undefined;

        // By default EventEmitters will print a warning if more than 10 listeners are
        // added to it. This is a useful default which helps finding memory leaks.
        EventEmitter.defaultMaxListeners = 10;

        // Obviously not all Emitters should be limited to 10. This function allows
        // that to be increased. Set to zero for unlimited.
        EventEmitter.prototype.setMaxListeners = function (n) {
            if (!isNumber(n) || n < 0 || isNaN(n))
                throw TypeError('n must be a positive number');
            this._maxListeners = n;
            return this;
        };

        EventEmitter.prototype.emit = function (type) {
            var er, handler, len, args, i, listeners;

            if (!this._events)
                this._events = {};

            // If there is no 'error' event listener then throw.
            if (type === 'error') {
                if (!this._events.error ||
                    (isObject(this._events.error) && !this._events.error.length)) {
                    er = arguments[1];
                    if (er instanceof Error) {
                        throw er; // Unhandled 'error' event
                    } else {
                        throw TypeError('Uncaught, unspecified "error" event.');
                    }
                    return false;
                }
            }

            handler = this._events[type];

            if (isUndefined(handler))
                return false;

            if (isFunction(handler)) {
                switch (arguments.length) {
                    // fast cases
                    case 1:
                        handler.call(this);
                        break;
                    case 2:
                        handler.call(this, arguments[1]);
                        break;
                    case 3:
                        handler.call(this, arguments[1], arguments[2]);
                        break;
                        // slower
                    default:
                        len = arguments.length;
                        args = new Array(len - 1);
                        for (i = 1; i < len; i++)
                            args[i - 1] = arguments[i];
                        handler.apply(this, args);
                }
            } else if (isObject(handler)) {
                len = arguments.length;
                args = new Array(len - 1);
                for (i = 1; i < len; i++)
                    args[i - 1] = arguments[i];

                listeners = handler.slice();
                len = listeners.length;
                for (i = 0; i < len; i++)
                    listeners[i].apply(this, args);
            }

            return true;
        };

        EventEmitter.prototype.addListener = function (type, listener) {
            var m;

            if (!isFunction(listener))
                throw TypeError('listener must be a function');

            if (!this._events)
                this._events = {};

            // To avoid recursion in the case that type === "newListener"! Before
            // adding it to the listeners, first emit "newListener".
            if (this._events.newListener)
                this.emit('newListener', type,
                          isFunction(listener.listener) ?
                          listener.listener : listener);

            if (!this._events[type])
                // Optimize the case of one listener. Don't need the extra array object.
                this._events[type] = listener;
            else if (isObject(this._events[type]))
                // If we've already got an array, just append.
                this._events[type].push(listener);
            else
                // Adding the second element, need to change to array.
                this._events[type] = [this._events[type], listener];

            // Check for listener leak
            if (isObject(this._events[type]) && !this._events[type].warned) {
                var m;
                if (!isUndefined(this._maxListeners)) {
                    m = this._maxListeners;
                } else {
                    m = EventEmitter.defaultMaxListeners;
                }

                if (m && m > 0 && this._events[type].length > m) {
                    this._events[type].warned = true;
                    console.error('(node) warning: possible EventEmitter memory ' +
                                  'leak detected. %d listeners added. ' +
                                  'Use emitter.setMaxListeners() to increase limit.',
                                  this._events[type].length);
                    if (typeof console.trace === 'function') {
                        // not supported in IE 10
                        console.trace();
                    }
                }
            }

            return this;
        };

        EventEmitter.prototype.on = EventEmitter.prototype.addListener;

        EventEmitter.prototype.once = function (type, listener) {
            if (!isFunction(listener))
                throw TypeError('listener must be a function');

            var fired = false;

            function g() {
                this.removeListener(type, g);

                if (!fired) {
                    fired = true;
                    listener.apply(this, arguments);
                }
            }

            g.listener = listener;
            this.on(type, g);

            return this;
        };

        // emits a 'removeListener' event iff the listener was removed
        EventEmitter.prototype.removeListener = function (type, listener) {
            var list, position, length, i;

            if (!isFunction(listener))
                throw TypeError('listener must be a function');

            if (!this._events || !this._events[type])
                return this;

            list = this._events[type];
            length = list.length;
            position = -1;

            if (list === listener ||
                (isFunction(list.listener) && list.listener === listener)) {
                delete this._events[type];
                if (this._events.removeListener)
                    this.emit('removeListener', type, listener);

            } else if (isObject(list)) {
                for (i = length; i-- > 0;) {
                    if (list[i] === listener ||
                        (list[i].listener && list[i].listener === listener)) {
                        position = i;
                        break;
                    }
                }

                if (position < 0)
                    return this;

                if (list.length === 1) {
                    list.length = 0;
                    delete this._events[type];
                } else {
                    list.splice(position, 1);
                }

                if (this._events.removeListener)
                    this.emit('removeListener', type, listener);
            }

            return this;
        };

        EventEmitter.prototype.removeAllListeners = function (type) {
            var key, listeners;

            if (!this._events)
                return this;

            // not listening for removeListener, no need to emit
            if (!this._events.removeListener) {
                if (arguments.length === 0)
                    this._events = {};
                else if (this._events[type])
                    delete this._events[type];
                return this;
            }

            // emit removeListener for all listeners on all events
            if (arguments.length === 0) {
                for (key in this._events) {
                    if (key === 'removeListener') continue;
                    this.removeAllListeners(key);
                }
                this.removeAllListeners('removeListener');
                this._events = {};
                return this;
            }

            listeners = this._events[type];

            if (isFunction(listeners)) {
                this.removeListener(type, listeners);
            } else {
                // LIFO order
                while (listeners.length)
                    this.removeListener(type, listeners[listeners.length - 1]);
            }
            delete this._events[type];

            return this;
        };

        EventEmitter.prototype.listeners = function (type) {
            var ret;
            if (!this._events || !this._events[type])
                ret = [];
            else if (isFunction(this._events[type]))
                ret = [this._events[type]];
            else
                ret = this._events[type].slice();
            return ret;
        };

        EventEmitter.listenerCount = function (emitter, type) {
            var ret;
            if (!emitter._events || !emitter._events[type])
                ret = 0;
            else if (isFunction(emitter._events[type]))
                ret = 1;
            else
                ret = emitter._events[type].length;
            return ret;
        };

        function isFunction(arg) {
            return typeof arg === 'function';
        }

        function isNumber(arg) {
            return typeof arg === 'number';
        }

        function isObject(arg) {
            return typeof arg === 'object' && arg !== null;
        }

        function isUndefined(arg) {
            return arg === void 0;
        }

    }, {}], 12: [function (require, module, exports) {
        if (typeof Object.create === 'function') {
            // implementation from standard node.js 'util' module
            module.exports = function inherits(ctor, superCtor) {
                ctor.super_ = superCtor
                ctor.prototype = Object.create(superCtor.prototype, {
                    constructor: {
                        value: ctor,
                        enumerable: false,
                        writable: true,
                        configurable: true
                    }
                });
            };
        } else {
            // old school shim for old browsers
            module.exports = function inherits(ctor, superCtor) {
                ctor.super_ = superCtor
                var TempCtor = function () { }
                TempCtor.prototype = superCtor.prototype
                ctor.prototype = new TempCtor()
                ctor.prototype.constructor = ctor
            }
        }

    }, {}], 13: [function (require, module, exports) {
        module.exports = Array.isArray || function (arr) {
            return Object.prototype.toString.call(arr) == '[object Array]';
        };

    }, {}], 14: [function (require, module, exports) {
        // shim for using process in browser

        var process = module.exports = {};

        process.nextTick = (function () {
            var canSetImmediate = typeof window !== 'undefined'
            && window.setImmediate;
            var canPost = typeof window !== 'undefined'
            && window.postMessage && window.addEventListener
            ;

            if (canSetImmediate) {
                return function (f) { return window.setImmediate(f) };
            }

            if (canPost) {
                var queue = [];
                window.addEventListener('message', function (ev) {
                    var source = ev.source;
                    if ((source === window || source === null) && ev.data === 'process-tick') {
                        ev.stopPropagation();
                        if (queue.length > 0) {
                            var fn = queue.shift();
                            fn();
                        }
                    }
                }, true);

                return function nextTick(fn) {
                    queue.push(fn);
                    window.postMessage('process-tick', '*');
                };
            }

            return function nextTick(fn) {
                setTimeout(fn, 0);
            };
        })();

        process.title = 'browser';
        process.browser = true;
        process.env = {};
        process.argv = [];

        function noop() { }

        process.on = noop;
        process.addListener = noop;
        process.once = noop;
        process.off = noop;
        process.removeListener = noop;
        process.removeAllListeners = noop;
        process.emit = noop;

        process.binding = function (name) {
            throw new Error('process.binding is not supported');
        }

        // TODO(shtylman)
        process.cwd = function () { return '/' };
        process.chdir = function (dir) {
            throw new Error('process.chdir is not supported');
        };

    }, {}], 15: [function (require, module, exports) {
        module.exports = require("./lib/_stream_duplex.js")

    }, { "./lib/_stream_duplex.js": 16 }], 16: [function (require, module, exports) {
        (function (process) {
            // Copyright Joyent, Inc. and other Node contributors.
            //
            // Permission is hereby granted, free of charge, to any person obtaining a
            // copy of this software and associated documentation files (the
            // "Software"), to deal in the Software without restriction, including
            // without limitation the rights to use, copy, modify, merge, publish,
            // distribute, sublicense, and/or sell copies of the Software, and to permit
            // persons to whom the Software is furnished to do so, subject to the
            // following conditions:
            //
            // The above copyright notice and this permission notice shall be included
            // in all copies or substantial portions of the Software.
            //
            // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
            // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
            // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
            // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
            // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
            // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
            // USE OR OTHER DEALINGS IN THE SOFTWARE.

            // a duplex stream is just a stream that is both readable and writable.
            // Since JS doesn't have multiple prototypal inheritance, this class
            // prototypally inherits from Readable, and then parasitically from
            // Writable.

            module.exports = Duplex;

            /*<replacement>*/
            var objectKeys = Object.keys || function (obj) {
                var keys = [];
                for (var key in obj) keys.push(key);
                return keys;
            }
            /*</replacement>*/


            /*<replacement>*/
            var util = require('core-util-is');
            util.inherits = require('inherits');
            /*</replacement>*/

            var Readable = require('./_stream_readable');
            var Writable = require('./_stream_writable');

            util.inherits(Duplex, Readable);

            forEach(objectKeys(Writable.prototype), function (method) {
                if (!Duplex.prototype[method])
                    Duplex.prototype[method] = Writable.prototype[method];
            });

            function Duplex(options) {
                if (!(this instanceof Duplex))
                    return new Duplex(options);

                Readable.call(this, options);
                Writable.call(this, options);

                if (options && options.readable === false)
                    this.readable = false;

                if (options && options.writable === false)
                    this.writable = false;

                this.allowHalfOpen = true;
                if (options && options.allowHalfOpen === false)
                    this.allowHalfOpen = false;

                this.once('end', onend);
            }

            // the no-half-open enforcer
            function onend() {
                // if we allow half-open state, or if the writable side ended,
                // then we're ok.
                if (this.allowHalfOpen || this._writableState.ended)
                    return;

                // no more data can be written.
                // But allow more writes to happen in this tick.
                process.nextTick(this.end.bind(this));
            }

            function forEach(xs, f) {
                for (var i = 0, l = xs.length; i < l; i++) {
                    f(xs[i], i);
                }
            }

        }).call(this, require('_process'))
    }, { "./_stream_readable": 18, "./_stream_writable": 20, "_process": 14, "core-util-is": 21, "inherits": 12 }], 17: [function (require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.

        // a passthrough stream.
        // basically just the most minimal sort of Transform stream.
        // Every written chunk gets output as-is.

        module.exports = PassThrough;

        var Transform = require('./_stream_transform');

        /*<replacement>*/
        var util = require('core-util-is');
        util.inherits = require('inherits');
        /*</replacement>*/

        util.inherits(PassThrough, Transform);

        function PassThrough(options) {
            if (!(this instanceof PassThrough))
                return new PassThrough(options);

            Transform.call(this, options);
        }

        PassThrough.prototype._transform = function (chunk, encoding, cb) {
            cb(null, chunk);
        };

    }, { "./_stream_transform": 19, "core-util-is": 21, "inherits": 12 }], 18: [function (require, module, exports) {
        (function (process) {
            // Copyright Joyent, Inc. and other Node contributors.
            //
            // Permission is hereby granted, free of charge, to any person obtaining a
            // copy of this software and associated documentation files (the
            // "Software"), to deal in the Software without restriction, including
            // without limitation the rights to use, copy, modify, merge, publish,
            // distribute, sublicense, and/or sell copies of the Software, and to permit
            // persons to whom the Software is furnished to do so, subject to the
            // following conditions:
            //
            // The above copyright notice and this permission notice shall be included
            // in all copies or substantial portions of the Software.
            //
            // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
            // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
            // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
            // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
            // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
            // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
            // USE OR OTHER DEALINGS IN THE SOFTWARE.

            module.exports = Readable;

            /*<replacement>*/
            var isArray = require('isarray');
            /*</replacement>*/


            /*<replacement>*/
            var Buffer = require('buffer').Buffer;
            /*</replacement>*/

            Readable.ReadableState = ReadableState;

            var EE = require('events').EventEmitter;

            /*<replacement>*/
            if (!EE.listenerCount) EE.listenerCount = function (emitter, type) {
                return emitter.listeners(type).length;
            };
            /*</replacement>*/

            var Stream = require('stream');

            /*<replacement>*/
            var util = require('core-util-is');
            util.inherits = require('inherits');
            /*</replacement>*/

            var StringDecoder;

            util.inherits(Readable, Stream);

            function ReadableState(options, stream) {
                options = options || {};

                // the point at which it stops calling _read() to fill the buffer
                // Note: 0 is a valid value, means "don't call _read preemptively ever"
                var hwm = options.highWaterMark;
                this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

                // cast to ints.
                this.highWaterMark = ~~this.highWaterMark;

                this.buffer = [];
                this.length = 0;
                this.pipes = null;
                this.pipesCount = 0;
                this.flowing = false;
                this.ended = false;
                this.endEmitted = false;
                this.reading = false;

                // In streams that never have any data, and do push(null) right away,
                // the consumer can miss the 'end' event if they do some I/O before
                // consuming the stream.  So, we don't emit('end') until some reading
                // happens.
                this.calledRead = false;

                // a flag to be able to tell if the onwrite cb is called immediately,
                // or on a later tick.  We set this to true at first, becuase any
                // actions that shouldn't happen until "later" should generally also
                // not happen before the first write call.
                this.sync = true;

                // whenever we return null, then we set a flag to say
                // that we're awaiting a 'readable' event emission.
                this.needReadable = false;
                this.emittedReadable = false;
                this.readableListening = false;


                // object stream flag. Used to make read(n) ignore n and to
                // make all the buffer merging and length checks go away
                this.objectMode = !!options.objectMode;

                // Crypto is kind of old and crusty.  Historically, its default string
                // encoding is 'binary' so we have to make this configurable.
                // Everything else in the universe uses 'utf8', though.
                this.defaultEncoding = options.defaultEncoding || 'utf8';

                // when piping, we only care about 'readable' events that happen
                // after read()ing all the bytes and not getting any pushback.
                this.ranOut = false;

                // the number of writers that are awaiting a drain event in .pipe()s
                this.awaitDrain = 0;

                // if true, a maybeReadMore has been scheduled
                this.readingMore = false;

                this.decoder = null;
                this.encoding = null;
                if (options.encoding) {
                    if (!StringDecoder)
                        StringDecoder = require('string_decoder/').StringDecoder;
                    this.decoder = new StringDecoder(options.encoding);
                    this.encoding = options.encoding;
                }
            }

            function Readable(options) {
                if (!(this instanceof Readable))
                    return new Readable(options);

                this._readableState = new ReadableState(options, this);

                // legacy
                this.readable = true;

                Stream.call(this);
            }

            // Manually shove something into the read() buffer.
            // This returns true if the highWaterMark has not been hit yet,
            // similar to how Writable.write() returns true if you should
            // write() some more.
            Readable.prototype.push = function (chunk, encoding) {
                var state = this._readableState;

                if (typeof chunk === 'string' && !state.objectMode) {
                    encoding = encoding || state.defaultEncoding;
                    if (encoding !== state.encoding) {
                        chunk = new Buffer(chunk, encoding);
                        encoding = '';
                    }
                }

                return readableAddChunk(this, state, chunk, encoding, false);
            };

            // Unshift should *always* be something directly out of read()
            Readable.prototype.unshift = function (chunk) {
                var state = this._readableState;
                return readableAddChunk(this, state, chunk, '', true);
            };

            function readableAddChunk(stream, state, chunk, encoding, addToFront) {
                var er = chunkInvalid(state, chunk);
                if (er) {
                    stream.emit('error', er);
                } else if (chunk === null || chunk === undefined) {
                    state.reading = false;
                    if (!state.ended)
                        onEofChunk(stream, state);
                } else if (state.objectMode || chunk && chunk.length > 0) {
                    if (state.ended && !addToFront) {
                        var e = new Error('stream.push() after EOF');
                        stream.emit('error', e);
                    } else if (state.endEmitted && addToFront) {
                        var e = new Error('stream.unshift() after end event');
                        stream.emit('error', e);
                    } else {
                        if (state.decoder && !addToFront && !encoding)
                            chunk = state.decoder.write(chunk);

                        // update the buffer info.
                        state.length += state.objectMode ? 1 : chunk.length;
                        if (addToFront) {
                            state.buffer.unshift(chunk);
                        } else {
                            state.reading = false;
                            state.buffer.push(chunk);
                        }

                        if (state.needReadable)
                            emitReadable(stream);

                        maybeReadMore(stream, state);
                    }
                } else if (!addToFront) {
                    state.reading = false;
                }

                return needMoreData(state);
            }



            // if it's past the high water mark, we can push in some more.
            // Also, if we have no data yet, we can stand some
            // more bytes.  This is to work around cases where hwm=0,
            // such as the repl.  Also, if the push() triggered a
            // readable event, and the user called read(largeNumber) such that
            // needReadable was set, then we ought to push more, so that another
            // 'readable' event will be triggered.
            function needMoreData(state) {
                return !state.ended &&
                       (state.needReadable ||
                        state.length < state.highWaterMark ||
                        state.length === 0);
            }

            // backwards compatibility.
            Readable.prototype.setEncoding = function (enc) {
                if (!StringDecoder)
                    StringDecoder = require('string_decoder/').StringDecoder;
                this._readableState.decoder = new StringDecoder(enc);
                this._readableState.encoding = enc;
            };

            // Don't raise the hwm > 128MB
            var MAX_HWM = 0x800000;
            function roundUpToNextPowerOf2(n) {
                if (n >= MAX_HWM) {
                    n = MAX_HWM;
                } else {
                    // Get the next highest power of 2
                    n--;
                    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
                    n++;
                }
                return n;
            }

            function howMuchToRead(n, state) {
                if (state.length === 0 && state.ended)
                    return 0;

                if (state.objectMode)
                    return n === 0 ? 0 : 1;

                if (n === null || isNaN(n)) {
                    // only flow one buffer at a time
                    if (state.flowing && state.buffer.length)
                        return state.buffer[0].length;
                    else
                        return state.length;
                }

                if (n <= 0)
                    return 0;

                // If we're asking for more than the target buffer level,
                // then raise the water mark.  Bump up to the next highest
                // power of 2, to prevent increasing it excessively in tiny
                // amounts.
                if (n > state.highWaterMark)
                    state.highWaterMark = roundUpToNextPowerOf2(n);

                // don't have that much.  return null, unless we've ended.
                if (n > state.length) {
                    if (!state.ended) {
                        state.needReadable = true;
                        return 0;
                    } else
                        return state.length;
                }

                return n;
            }

            // you can override either this method, or the async _read(n) below.
            Readable.prototype.read = function (n) {
                var state = this._readableState;
                state.calledRead = true;
                var nOrig = n;
                var ret;

                if (typeof n !== 'number' || n > 0)
                    state.emittedReadable = false;

                // if we're doing read(0) to trigger a readable event, but we
                // already have a bunch of data in the buffer, then just trigger
                // the 'readable' event and move on.
                if (n === 0 &&
                    state.needReadable &&
                    (state.length >= state.highWaterMark || state.ended)) {
                    emitReadable(this);
                    return null;
                }

                n = howMuchToRead(n, state);

                // if we've ended, and we're now clear, then finish it up.
                if (n === 0 && state.ended) {
                    ret = null;

                    // In cases where the decoder did not receive enough data
                    // to produce a full chunk, then immediately received an
                    // EOF, state.buffer will contain [<Buffer >, <Buffer 00 ...>].
                    // howMuchToRead will see this and coerce the amount to
                    // read to zero (because it's looking at the length of the
                    // first <Buffer > in state.buffer), and we'll end up here.
                    //
                    // This can only happen via state.decoder -- no other venue
                    // exists for pushing a zero-length chunk into state.buffer
                    // and triggering this behavior. In this case, we return our
                    // remaining data and end the stream, if appropriate.
                    if (state.length > 0 && state.decoder) {
                        ret = fromList(n, state);
                        state.length -= ret.length;
                    }

                    if (state.length === 0)
                        endReadable(this);

                    return ret;
                }

                // All the actual chunk generation logic needs to be
                // *below* the call to _read.  The reason is that in certain
                // synthetic stream cases, such as passthrough streams, _read
                // may be a completely synchronous operation which may change
                // the state of the read buffer, providing enough data when
                // before there was *not* enough.
                //
                // So, the steps are:
                // 1. Figure out what the state of things will be after we do
                // a read from the buffer.
                //
                // 2. If that resulting state will trigger a _read, then call _read.
                // Note that this may be asynchronous, or synchronous.  Yes, it is
                // deeply ugly to write APIs this way, but that still doesn't mean
                // that the Readable class should behave improperly, as streams are
                // designed to be sync/async agnostic.
                // Take note if the _read call is sync or async (ie, if the read call
                // has returned yet), so that we know whether or not it's safe to emit
                // 'readable' etc.
                //
                // 3. Actually pull the requested chunks out of the buffer and return.

                // if we need a readable event, then we need to do some reading.
                var doRead = state.needReadable;

                // if we currently have less than the highWaterMark, then also read some
                if (state.length - n <= state.highWaterMark)
                    doRead = true;

                // however, if we've ended, then there's no point, and if we're already
                // reading, then it's unnecessary.
                if (state.ended || state.reading)
                    doRead = false;

                if (doRead) {
                    state.reading = true;
                    state.sync = true;
                    // if the length is currently zero, then we *need* a readable event.
                    if (state.length === 0)
                        state.needReadable = true;
                    // call internal read method
                    this._read(state.highWaterMark);
                    state.sync = false;
                }

                // If _read called its callback synchronously, then `reading`
                // will be false, and we need to re-evaluate how much data we
                // can return to the user.
                if (doRead && !state.reading)
                    n = howMuchToRead(nOrig, state);

                if (n > 0)
                    ret = fromList(n, state);
                else
                    ret = null;

                if (ret === null) {
                    state.needReadable = true;
                    n = 0;
                }

                state.length -= n;

                // If we have nothing in the buffer, then we want to know
                // as soon as we *do* get something into the buffer.
                if (state.length === 0 && !state.ended)
                    state.needReadable = true;

                // If we happened to read() exactly the remaining amount in the
                // buffer, and the EOF has been seen at this point, then make sure
                // that we emit 'end' on the very next tick.
                if (state.ended && !state.endEmitted && state.length === 0)
                    endReadable(this);

                return ret;
            };

            function chunkInvalid(state, chunk) {
                var er = null;
                if (!Buffer.isBuffer(chunk) &&
                    'string' !== typeof chunk &&
                    chunk !== null &&
                    chunk !== undefined &&
                    !state.objectMode) {
                    er = new TypeError('Invalid non-string/buffer chunk');
                }
                return er;
            }


            function onEofChunk(stream, state) {
                if (state.decoder && !state.ended) {
                    var chunk = state.decoder.end();
                    if (chunk && chunk.length) {
                        state.buffer.push(chunk);
                        state.length += state.objectMode ? 1 : chunk.length;
                    }
                }
                state.ended = true;

                // if we've ended and we have some data left, then emit
                // 'readable' now to make sure it gets picked up.
                if (state.length > 0)
                    emitReadable(stream);
                else
                    endReadable(stream);
            }

            // Don't emit readable right away in sync mode, because this can trigger
            // another read() call => stack overflow.  This way, it might trigger
            // a nextTick recursion warning, but that's not so bad.
            function emitReadable(stream) {
                var state = stream._readableState;
                state.needReadable = false;
                if (state.emittedReadable)
                    return;

                state.emittedReadable = true;
                if (state.sync)
                    process.nextTick(function () {
                        emitReadable_(stream);
                    });
                else
                    emitReadable_(stream);
            }

            function emitReadable_(stream) {
                stream.emit('readable');
            }


            // at this point, the user has presumably seen the 'readable' event,
            // and called read() to consume some data.  that may have triggered
            // in turn another _read(n) call, in which case reading = true if
            // it's in progress.
            // However, if we're not ended, or reading, and the length < hwm,
            // then go ahead and try to read some more preemptively.
            function maybeReadMore(stream, state) {
                if (!state.readingMore) {
                    state.readingMore = true;
                    process.nextTick(function () {
                        maybeReadMore_(stream, state);
                    });
                }
            }

            function maybeReadMore_(stream, state) {
                var len = state.length;
                while (!state.reading && !state.flowing && !state.ended &&
                       state.length < state.highWaterMark) {
                    stream.read(0);
                    if (len === state.length)
                        // didn't get any data, stop spinning.
                        break;
                    else
                        len = state.length;
                }
                state.readingMore = false;
            }

            // abstract method.  to be overridden in specific implementation classes.
            // call cb(er, data) where data is <= n in length.
            // for virtual (non-string, non-buffer) streams, "length" is somewhat
            // arbitrary, and perhaps not very meaningful.
            Readable.prototype._read = function (n) {
                this.emit('error', new Error('not implemented'));
            };

            Readable.prototype.pipe = function (dest, pipeOpts) {
                var src = this;
                var state = this._readableState;

                switch (state.pipesCount) {
                    case 0:
                        state.pipes = dest;
                        break;
                    case 1:
                        state.pipes = [state.pipes, dest];
                        break;
                    default:
                        state.pipes.push(dest);
                        break;
                }
                state.pipesCount += 1;

                var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
                            dest !== process.stdout &&
                            dest !== process.stderr;

                var endFn = doEnd ? onend : cleanup;
                if (state.endEmitted)
                    process.nextTick(endFn);
                else
                    src.once('end', endFn);

                dest.on('unpipe', onunpipe);
                function onunpipe(readable) {
                    if (readable !== src) return;
                    cleanup();
                }

                function onend() {
                    dest.end();
                }

                // when the dest drains, it reduces the awaitDrain counter
                // on the source.  This would be more elegant with a .once()
                // handler in flow(), but adding and removing repeatedly is
                // too slow.
                var ondrain = pipeOnDrain(src);
                dest.on('drain', ondrain);

                function cleanup() {
                    // cleanup event handlers once the pipe is broken
                    dest.removeListener('close', onclose);
                    dest.removeListener('finish', onfinish);
                    dest.removeListener('drain', ondrain);
                    dest.removeListener('error', onerror);
                    dest.removeListener('unpipe', onunpipe);
                    src.removeListener('end', onend);
                    src.removeListener('end', cleanup);

                    // if the reader is waiting for a drain event from this
                    // specific writer, then it would cause it to never start
                    // flowing again.
                    // So, if this is awaiting a drain, then we just call it now.
                    // If we don't know, then assume that we are waiting for one.
                    if (!dest._writableState || dest._writableState.needDrain)
                        ondrain();
                }

                // if the dest has an error, then stop piping into it.
                // however, don't suppress the throwing behavior for this.
                function onerror(er) {
                    unpipe();
                    dest.removeListener('error', onerror);
                    if (EE.listenerCount(dest, 'error') === 0)
                        dest.emit('error', er);
                }
                // This is a brutally ugly hack to make sure that our error handler
                // is attached before any userland ones.  NEVER DO THIS.
                if (!dest._events || !dest._events.error)
                    dest.on('error', onerror);
                else if (isArray(dest._events.error))
                    dest._events.error.unshift(onerror);
                else
                    dest._events.error = [onerror, dest._events.error];



                // Both close and finish should trigger unpipe, but only once.
                function onclose() {
                    dest.removeListener('finish', onfinish);
                    unpipe();
                }
                dest.once('close', onclose);
                function onfinish() {
                    dest.removeListener('close', onclose);
                    unpipe();
                }
                dest.once('finish', onfinish);

                function unpipe() {
                    src.unpipe(dest);
                }

                // tell the dest that it's being piped to
                dest.emit('pipe', src);

                // start the flow if it hasn't been started already.
                if (!state.flowing) {
                    // the handler that waits for readable events after all
                    // the data gets sucked out in flow.
                    // This would be easier to follow with a .once() handler
                    // in flow(), but that is too slow.
                    this.on('readable', pipeOnReadable);

                    state.flowing = true;
                    process.nextTick(function () {
                        flow(src);
                    });
                }

                return dest;
            };

            function pipeOnDrain(src) {
                return function () {
                    var dest = this;
                    var state = src._readableState;
                    state.awaitDrain--;
                    if (state.awaitDrain === 0)
                        flow(src);
                };
            }

            function flow(src) {
                var state = src._readableState;
                var chunk;
                state.awaitDrain = 0;

                function write(dest, i, list) {
                    var written = dest.write(chunk);
                    if (false === written) {
                        state.awaitDrain++;
                    }
                }

                while (state.pipesCount && null !== (chunk = src.read())) {

                    if (state.pipesCount === 1)
                        write(state.pipes, 0, null);
                    else
                        forEach(state.pipes, write);

                    src.emit('data', chunk);

                    // if anyone needs a drain, then we have to wait for that.
                    if (state.awaitDrain > 0)
                        return;
                }

                // if every destination was unpiped, either before entering this
                // function, or in the while loop, then stop flowing.
                //
                // NB: This is a pretty rare edge case.
                if (state.pipesCount === 0) {
                    state.flowing = false;

                    // if there were data event listeners added, then switch to old mode.
                    if (EE.listenerCount(src, 'data') > 0)
                        emitDataEvents(src);
                    return;
                }

                // at this point, no one needed a drain, so we just ran out of data
                // on the next readable event, start it over again.
                state.ranOut = true;
            }

            function pipeOnReadable() {
                if (this._readableState.ranOut) {
                    this._readableState.ranOut = false;
                    flow(this);
                }
            }


            Readable.prototype.unpipe = function (dest) {
                var state = this._readableState;

                // if we're not piping anywhere, then do nothing.
                if (state.pipesCount === 0)
                    return this;

                // just one destination.  most common case.
                if (state.pipesCount === 1) {
                    // passed in one, but it's not the right one.
                    if (dest && dest !== state.pipes)
                        return this;

                    if (!dest)
                        dest = state.pipes;

                    // got a match.
                    state.pipes = null;
                    state.pipesCount = 0;
                    this.removeListener('readable', pipeOnReadable);
                    state.flowing = false;
                    if (dest)
                        dest.emit('unpipe', this);
                    return this;
                }

                // slow case. multiple pipe destinations.

                if (!dest) {
                    // remove all.
                    var dests = state.pipes;
                    var len = state.pipesCount;
                    state.pipes = null;
                    state.pipesCount = 0;
                    this.removeListener('readable', pipeOnReadable);
                    state.flowing = false;

                    for (var i = 0; i < len; i++)
                        dests[i].emit('unpipe', this);
                    return this;
                }

                // try to find the right one.
                var i = indexOf(state.pipes, dest);
                if (i === -1)
                    return this;

                state.pipes.splice(i, 1);
                state.pipesCount -= 1;
                if (state.pipesCount === 1)
                    state.pipes = state.pipes[0];

                dest.emit('unpipe', this);

                return this;
            };

            // set up data events if they are asked for
            // Ensure readable listeners eventually get something
            Readable.prototype.on = function (ev, fn) {
                var res = Stream.prototype.on.call(this, ev, fn);

                if (ev === 'data' && !this._readableState.flowing)
                    emitDataEvents(this);

                if (ev === 'readable' && this.readable) {
                    var state = this._readableState;
                    if (!state.readableListening) {
                        state.readableListening = true;
                        state.emittedReadable = false;
                        state.needReadable = true;
                        if (!state.reading) {
                            this.read(0);
                        } else if (state.length) {
                            emitReadable(this, state);
                        }
                    }
                }

                return res;
            };
            Readable.prototype.addListener = Readable.prototype.on;

            // pause() and resume() are remnants of the legacy readable stream API
            // If the user uses them, then switch into old mode.
            Readable.prototype.resume = function () {
                emitDataEvents(this);
                this.read(0);
                this.emit('resume');
            };

            Readable.prototype.pause = function () {
                emitDataEvents(this, true);
                this.emit('pause');
            };

            function emitDataEvents(stream, startPaused) {
                var state = stream._readableState;

                if (state.flowing) {
                    // https://github.com/isaacs/readable-stream/issues/16
                    throw new Error('Cannot switch to old mode now.');
                }

                var paused = startPaused || false;
                var readable = false;

                // convert to an old-style stream.
                stream.readable = true;
                stream.pipe = Stream.prototype.pipe;
                stream.on = stream.addListener = Stream.prototype.on;

                stream.on('readable', function () {
                    readable = true;

                    var c;
                    while (!paused && (null !== (c = stream.read())))
                        stream.emit('data', c);

                    if (c === null) {
                        readable = false;
                        stream._readableState.needReadable = true;
                    }
                });

                stream.pause = function () {
                    paused = true;
                    this.emit('pause');
                };

                stream.resume = function () {
                    paused = false;
                    if (readable)
                        process.nextTick(function () {
                            stream.emit('readable');
                        });
                    else
                        this.read(0);
                    this.emit('resume');
                };

                // now make it start, just in case it hadn't already.
                stream.emit('readable');
            }

            // wrap an old-style stream as the async data source.
            // This is *not* part of the readable stream interface.
            // It is an ugly unfortunate mess of history.
            Readable.prototype.wrap = function (stream) {
                var state = this._readableState;
                var paused = false;

                var self = this;
                stream.on('end', function () {
                    if (state.decoder && !state.ended) {
                        var chunk = state.decoder.end();
                        if (chunk && chunk.length)
                            self.push(chunk);
                    }

                    self.push(null);
                });

                stream.on('data', function (chunk) {
                    if (state.decoder)
                        chunk = state.decoder.write(chunk);

                    // don't skip over falsy values in objectMode
                    //if (state.objectMode && util.isNullOrUndefined(chunk))
                    if (state.objectMode && (chunk === null || chunk === undefined))
                        return;
                    else if (!state.objectMode && (!chunk || !chunk.length))
                        return;

                    var ret = self.push(chunk);
                    if (!ret) {
                        paused = true;
                        stream.pause();
                    }
                });

                // proxy all the other methods.
                // important when wrapping filters and duplexes.
                for (var i in stream) {
                    if (typeof stream[i] === 'function' &&
                        typeof this[i] === 'undefined') {
                        this[i] = function (method) {
                            return function () {
                                return stream[method].apply(stream, arguments);
                            }
                        }(i);
                    }
                }

                // proxy certain important events.
                var events = ['error', 'close', 'destroy', 'pause', 'resume'];
                forEach(events, function (ev) {
                    stream.on(ev, self.emit.bind(self, ev));
                });

                // when we try to consume some more bytes, simply unpause the
                // underlying stream.
                self._read = function (n) {
                    if (paused) {
                        paused = false;
                        stream.resume();
                    }
                };

                return self;
            };



            // exposed for testing purposes only.
            Readable._fromList = fromList;

            // Pluck off n bytes from an array of buffers.
            // Length is the combined lengths of all the buffers in the list.
            function fromList(n, state) {
                var list = state.buffer;
                var length = state.length;
                var stringMode = !!state.decoder;
                var objectMode = !!state.objectMode;
                var ret;

                // nothing in the list, definitely empty.
                if (list.length === 0)
                    return null;

                if (length === 0)
                    ret = null;
                else if (objectMode)
                    ret = list.shift();
                else if (!n || n >= length) {
                    // read it all, truncate the array.
                    if (stringMode)
                        ret = list.join('');
                    else
                        ret = Buffer.concat(list, length);
                    list.length = 0;
                } else {
                    // read just some of it.
                    if (n < list[0].length) {
                        // just take a part of the first list item.
                        // slice is the same for buffers and strings.
                        var buf = list[0];
                        ret = buf.slice(0, n);
                        list[0] = buf.slice(n);
                    } else if (n === list[0].length) {
                        // first list is a perfect match
                        ret = list.shift();
                    } else {
                        // complex case.
                        // we have enough to cover it, but it spans past the first buffer.
                        if (stringMode)
                            ret = '';
                        else
                            ret = new Buffer(n);

                        var c = 0;
                        for (var i = 0, l = list.length; i < l && c < n; i++) {
                            var buf = list[0];
                            var cpy = Math.min(n - c, buf.length);

                            if (stringMode)
                                ret += buf.slice(0, cpy);
                            else
                                buf.copy(ret, c, 0, cpy);

                            if (cpy < buf.length)
                                list[0] = buf.slice(cpy);
                            else
                                list.shift();

                            c += cpy;
                        }
                    }
                }

                return ret;
            }

            function endReadable(stream) {
                var state = stream._readableState;

                // If we get here before consuming all the bytes, then that is a
                // bug in node.  Should never happen.
                if (state.length > 0)
                    throw new Error('endReadable called on non-empty stream');

                if (!state.endEmitted && state.calledRead) {
                    state.ended = true;
                    process.nextTick(function () {
                        // Check that we didn't get one last unshift.
                        if (!state.endEmitted && state.length === 0) {
                            state.endEmitted = true;
                            stream.readable = false;
                            stream.emit('end');
                        }
                    });
                }
            }

            function forEach(xs, f) {
                for (var i = 0, l = xs.length; i < l; i++) {
                    f(xs[i], i);
                }
            }

            function indexOf(xs, x) {
                for (var i = 0, l = xs.length; i < l; i++) {
                    if (xs[i] === x) return i;
                }
                return -1;
            }

        }).call(this, require('_process'))
    }, { "_process": 14, "buffer": 8, "core-util-is": 21, "events": 11, "inherits": 12, "isarray": 13, "stream": 27, "string_decoder/": 22 }], 19: [function (require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.


        // a transform stream is a readable/writable stream where you do
        // something with the data.  Sometimes it's called a "filter",
        // but that's not a great name for it, since that implies a thing where
        // some bits pass through, and others are simply ignored.  (That would
        // be a valid example of a transform, of course.)
        //
        // While the output is causally related to the input, it's not a
        // necessarily symmetric or synchronous transformation.  For example,
        // a zlib stream might take multiple plain-text writes(), and then
        // emit a single compressed chunk some time in the future.
        //
        // Here's how this works:
        //
        // The Transform stream has all the aspects of the readable and writable
        // stream classes.  When you write(chunk), that calls _write(chunk,cb)
        // internally, and returns false if there's a lot of pending writes
        // buffered up.  When you call read(), that calls _read(n) until
        // there's enough pending readable data buffered up.
        //
        // In a transform stream, the written data is placed in a buffer.  When
        // _read(n) is called, it transforms the queued up data, calling the
        // buffered _write cb's as it consumes chunks.  If consuming a single
        // written chunk would result in multiple output chunks, then the first
        // outputted bit calls the readcb, and subsequent chunks just go into
        // the read buffer, and will cause it to emit 'readable' if necessary.
        //
        // This way, back-pressure is actually determined by the reading side,
        // since _read has to be called to start processing a new chunk.  However,
        // a pathological inflate type of transform can cause excessive buffering
        // here.  For example, imagine a stream where every byte of input is
        // interpreted as an integer from 0-255, and then results in that many
        // bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
        // 1kb of data being output.  In this case, you could write a very small
        // amount of input, and end up with a very large amount of output.  In
        // such a pathological inflating mechanism, there'd be no way to tell
        // the system to stop doing the transform.  A single 4MB write could
        // cause the system to run out of memory.
        //
        // However, even in such a pathological case, only a single written chunk
        // would be consumed, and then the rest would wait (un-transformed) until
        // the results of the previous transformed chunk were consumed.

        module.exports = Transform;

        var Duplex = require('./_stream_duplex');

        /*<replacement>*/
        var util = require('core-util-is');
        util.inherits = require('inherits');
        /*</replacement>*/

        util.inherits(Transform, Duplex);


        function TransformState(options, stream) {
            this.afterTransform = function (er, data) {
                return afterTransform(stream, er, data);
            };

            this.needTransform = false;
            this.transforming = false;
            this.writecb = null;
            this.writechunk = null;
        }

        function afterTransform(stream, er, data) {
            var ts = stream._transformState;
            ts.transforming = false;

            var cb = ts.writecb;

            if (!cb)
                return stream.emit('error', new Error('no writecb in Transform class'));

            ts.writechunk = null;
            ts.writecb = null;

            if (data !== null && data !== undefined)
                stream.push(data);

            if (cb)
                cb(er);

            var rs = stream._readableState;
            rs.reading = false;
            if (rs.needReadable || rs.length < rs.highWaterMark) {
                stream._read(rs.highWaterMark);
            }
        }


        function Transform(options) {
            if (!(this instanceof Transform))
                return new Transform(options);

            Duplex.call(this, options);

            var ts = this._transformState = new TransformState(options, this);

            // when the writable side finishes, then flush out anything remaining.
            var stream = this;

            // start out asking for a readable event once data is transformed.
            this._readableState.needReadable = true;

            // we have implemented the _read method, and done the other things
            // that Readable wants before the first _read call, so unset the
            // sync guard flag.
            this._readableState.sync = false;

            this.once('finish', function () {
                if ('function' === typeof this._flush)
                    this._flush(function (er) {
                        done(stream, er);
                    });
                else
                    done(stream);
            });
        }

        Transform.prototype.push = function (chunk, encoding) {
            this._transformState.needTransform = false;
            return Duplex.prototype.push.call(this, chunk, encoding);
        };

        // This is the part where you do stuff!
        // override this function in implementation classes.
        // 'chunk' is an input chunk.
        //
        // Call `push(newChunk)` to pass along transformed output
        // to the readable side.  You may call 'push' zero or more times.
        //
        // Call `cb(err)` when you are done with this chunk.  If you pass
        // an error, then that'll put the hurt on the whole operation.  If you
        // never call cb(), then you'll never get another chunk.
        Transform.prototype._transform = function (chunk, encoding, cb) {
            throw new Error('not implemented');
        };

        Transform.prototype._write = function (chunk, encoding, cb) {
            var ts = this._transformState;
            ts.writecb = cb;
            ts.writechunk = chunk;
            ts.writeencoding = encoding;
            if (!ts.transforming) {
                var rs = this._readableState;
                if (ts.needTransform ||
                    rs.needReadable ||
                    rs.length < rs.highWaterMark)
                    this._read(rs.highWaterMark);
            }
        };

        // Doesn't matter what the args are here.
        // _transform does all the work.
        // That we got here means that the readable side wants more data.
        Transform.prototype._read = function (n) {
            var ts = this._transformState;

            if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
                ts.transforming = true;
                this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
            } else {
                // mark that we need a transform, so that any data that comes in
                // will get processed, now that we've asked for it.
                ts.needTransform = true;
            }
        };


        function done(stream, er) {
            if (er)
                return stream.emit('error', er);

            // if there's nothing in the write buffer, then that means
            // that nothing more will ever be provided
            var ws = stream._writableState;
            var rs = stream._readableState;
            var ts = stream._transformState;

            if (ws.length)
                throw new Error('calling transform done when ws.length != 0');

            if (ts.transforming)
                throw new Error('calling transform done when still transforming');

            return stream.push(null);
        }

    }, { "./_stream_duplex": 16, "core-util-is": 21, "inherits": 12 }], 20: [function (require, module, exports) {
        (function (process) {
            // Copyright Joyent, Inc. and other Node contributors.
            //
            // Permission is hereby granted, free of charge, to any person obtaining a
            // copy of this software and associated documentation files (the
            // "Software"), to deal in the Software without restriction, including
            // without limitation the rights to use, copy, modify, merge, publish,
            // distribute, sublicense, and/or sell copies of the Software, and to permit
            // persons to whom the Software is furnished to do so, subject to the
            // following conditions:
            //
            // The above copyright notice and this permission notice shall be included
            // in all copies or substantial portions of the Software.
            //
            // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
            // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
            // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
            // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
            // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
            // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
            // USE OR OTHER DEALINGS IN THE SOFTWARE.

            // A bit simpler than readable streams.
            // Implement an async ._write(chunk, cb), and it'll handle all
            // the drain event emission and buffering.

            module.exports = Writable;

            /*<replacement>*/
            var Buffer = require('buffer').Buffer;
            /*</replacement>*/

            Writable.WritableState = WritableState;


            /*<replacement>*/
            var util = require('core-util-is');
            util.inherits = require('inherits');
            /*</replacement>*/

            var Stream = require('stream');

            util.inherits(Writable, Stream);

            function WriteReq(chunk, encoding, cb) {
                this.chunk = chunk;
                this.encoding = encoding;
                this.callback = cb;
            }

            function WritableState(options, stream) {
                options = options || {};

                // the point at which write() starts returning false
                // Note: 0 is a valid value, means that we always return false if
                // the entire buffer is not flushed immediately on write()
                var hwm = options.highWaterMark;
                this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

                // object stream flag to indicate whether or not this stream
                // contains buffers or objects.
                this.objectMode = !!options.objectMode;

                // cast to ints.
                this.highWaterMark = ~~this.highWaterMark;

                this.needDrain = false;
                // at the start of calling end()
                this.ending = false;
                // when end() has been called, and returned
                this.ended = false;
                // when 'finish' is emitted
                this.finished = false;

                // should we decode strings into buffers before passing to _write?
                // this is here so that some node-core streams can optimize string
                // handling at a lower level.
                var noDecode = options.decodeStrings === false;
                this.decodeStrings = !noDecode;

                // Crypto is kind of old and crusty.  Historically, its default string
                // encoding is 'binary' so we have to make this configurable.
                // Everything else in the universe uses 'utf8', though.
                this.defaultEncoding = options.defaultEncoding || 'utf8';

                // not an actual buffer we keep track of, but a measurement
                // of how much we're waiting to get pushed to some underlying
                // socket or file.
                this.length = 0;

                // a flag to see when we're in the middle of a write.
                this.writing = false;

                // a flag to be able to tell if the onwrite cb is called immediately,
                // or on a later tick.  We set this to true at first, becuase any
                // actions that shouldn't happen until "later" should generally also
                // not happen before the first write call.
                this.sync = true;

                // a flag to know if we're processing previously buffered items, which
                // may call the _write() callback in the same tick, so that we don't
                // end up in an overlapped onwrite situation.
                this.bufferProcessing = false;

                // the callback that's passed to _write(chunk,cb)
                this.onwrite = function (er) {
                    onwrite(stream, er);
                };

                // the callback that the user supplies to write(chunk,encoding,cb)
                this.writecb = null;

                // the amount that is being written when _write is called.
                this.writelen = 0;

                this.buffer = [];

                // True if the error was already emitted and should not be thrown again
                this.errorEmitted = false;
            }

            function Writable(options) {
                var Duplex = require('./_stream_duplex');

                // Writable ctor is applied to Duplexes, though they're not
                // instanceof Writable, they're instanceof Readable.
                if (!(this instanceof Writable) && !(this instanceof Duplex))
                    return new Writable(options);

                this._writableState = new WritableState(options, this);

                // legacy.
                this.writable = true;

                Stream.call(this);
            }

            // Otherwise people can pipe Writable streams, which is just wrong.
            Writable.prototype.pipe = function () {
                this.emit('error', new Error('Cannot pipe. Not readable.'));
            };


            function writeAfterEnd(stream, state, cb) {
                var er = new Error('write after end');
                // TODO: defer error events consistently everywhere, not just the cb
                stream.emit('error', er);
                process.nextTick(function () {
                    cb(er);
                });
            }

            // If we get something that is not a buffer, string, null, or undefined,
            // and we're not in objectMode, then that's an error.
            // Otherwise stream chunks are all considered to be of length=1, and the
            // watermarks determine how many objects to keep in the buffer, rather than
            // how many bytes or characters.
            function validChunk(stream, state, chunk, cb) {
                var valid = true;
                if (!Buffer.isBuffer(chunk) &&
                    'string' !== typeof chunk &&
                    chunk !== null &&
                    chunk !== undefined &&
                    !state.objectMode) {
                    var er = new TypeError('Invalid non-string/buffer chunk');
                    stream.emit('error', er);
                    process.nextTick(function () {
                        cb(er);
                    });
                    valid = false;
                }
                return valid;
            }

            Writable.prototype.write = function (chunk, encoding, cb) {
                var state = this._writableState;
                var ret = false;

                if (typeof encoding === 'function') {
                    cb = encoding;
                    encoding = null;
                }

                if (Buffer.isBuffer(chunk))
                    encoding = 'buffer';
                else if (!encoding)
                    encoding = state.defaultEncoding;

                if (typeof cb !== 'function')
                    cb = function () { };

                if (state.ended)
                    writeAfterEnd(this, state, cb);
                else if (validChunk(this, state, chunk, cb))
                    ret = writeOrBuffer(this, state, chunk, encoding, cb);

                return ret;
            };

            function decodeChunk(state, chunk, encoding) {
                if (!state.objectMode &&
                    state.decodeStrings !== false &&
                    typeof chunk === 'string') {
                    chunk = new Buffer(chunk, encoding);
                }
                return chunk;
            }

            // if we're already writing something, then just put this
            // in the queue, and wait our turn.  Otherwise, call _write
            // If we return false, then we need a drain event, so set that flag.
            function writeOrBuffer(stream, state, chunk, encoding, cb) {
                chunk = decodeChunk(state, chunk, encoding);
                if (Buffer.isBuffer(chunk))
                    encoding = 'buffer';
                var len = state.objectMode ? 1 : chunk.length;

                state.length += len;

                var ret = state.length < state.highWaterMark;
                // we must ensure that previous needDrain will not be reset to false.
                if (!ret)
                    state.needDrain = true;

                if (state.writing)
                    state.buffer.push(new WriteReq(chunk, encoding, cb));
                else
                    doWrite(stream, state, len, chunk, encoding, cb);

                return ret;
            }

            function doWrite(stream, state, len, chunk, encoding, cb) {
                state.writelen = len;
                state.writecb = cb;
                state.writing = true;
                state.sync = true;
                stream._write(chunk, encoding, state.onwrite);
                state.sync = false;
            }

            function onwriteError(stream, state, sync, er, cb) {
                if (sync)
                    process.nextTick(function () {
                        cb(er);
                    });
                else
                    cb(er);

                stream._writableState.errorEmitted = true;
                stream.emit('error', er);
            }

            function onwriteStateUpdate(state) {
                state.writing = false;
                state.writecb = null;
                state.length -= state.writelen;
                state.writelen = 0;
            }

            function onwrite(stream, er) {
                var state = stream._writableState;
                var sync = state.sync;
                var cb = state.writecb;

                onwriteStateUpdate(state);

                if (er)
                    onwriteError(stream, state, sync, er, cb);
                else {
                    // Check if we're actually ready to finish, but don't emit yet
                    var finished = needFinish(stream, state);

                    if (!finished && !state.bufferProcessing && state.buffer.length)
                        clearBuffer(stream, state);

                    if (sync) {
                        process.nextTick(function () {
                            afterWrite(stream, state, finished, cb);
                        });
                    } else {
                        afterWrite(stream, state, finished, cb);
                    }
                }
            }

            function afterWrite(stream, state, finished, cb) {
                if (!finished)
                    onwriteDrain(stream, state);
                cb();
                if (finished)
                    finishMaybe(stream, state);
            }

            // Must force callback to be called on nextTick, so that we don't
            // emit 'drain' before the write() consumer gets the 'false' return
            // value, and has a chance to attach a 'drain' listener.
            function onwriteDrain(stream, state) {
                if (state.length === 0 && state.needDrain) {
                    state.needDrain = false;
                    stream.emit('drain');
                }
            }


            // if there's something in the buffer waiting, then process it
            function clearBuffer(stream, state) {
                state.bufferProcessing = true;

                for (var c = 0; c < state.buffer.length; c++) {
                    var entry = state.buffer[c];
                    var chunk = entry.chunk;
                    var encoding = entry.encoding;
                    var cb = entry.callback;
                    var len = state.objectMode ? 1 : chunk.length;

                    doWrite(stream, state, len, chunk, encoding, cb);

                    // if we didn't call the onwrite immediately, then
                    // it means that we need to wait until it does.
                    // also, that means that the chunk and cb are currently
                    // being processed, so move the buffer counter past them.
                    if (state.writing) {
                        c++;
                        break;
                    }
                }

                state.bufferProcessing = false;
                if (c < state.buffer.length)
                    state.buffer = state.buffer.slice(c);
                else
                    state.buffer.length = 0;
            }

            Writable.prototype._write = function (chunk, encoding, cb) {
                cb(new Error('not implemented'));
            };

            Writable.prototype.end = function (chunk, encoding, cb) {
                var state = this._writableState;

                if (typeof chunk === 'function') {
                    cb = chunk;
                    chunk = null;
                    encoding = null;
                } else if (typeof encoding === 'function') {
                    cb = encoding;
                    encoding = null;
                }

                if (typeof chunk !== 'undefined' && chunk !== null)
                    this.write(chunk, encoding);

                // ignore unnecessary end() calls.
                if (!state.ending && !state.finished)
                    endWritable(this, state, cb);
            };


            function needFinish(stream, state) {
                return (state.ending &&
                        state.length === 0 &&
                        !state.finished &&
                        !state.writing);
            }

            function finishMaybe(stream, state) {
                var need = needFinish(stream, state);
                if (need) {
                    state.finished = true;
                    stream.emit('finish');
                }
                return need;
            }

            function endWritable(stream, state, cb) {
                state.ending = true;
                finishMaybe(stream, state);
                if (cb) {
                    if (state.finished)
                        process.nextTick(cb);
                    else
                        stream.once('finish', cb);
                }
                state.ended = true;
            }

        }).call(this, require('_process'))
    }, { "./_stream_duplex": 16, "_process": 14, "buffer": 8, "core-util-is": 21, "inherits": 12, "stream": 27 }], 21: [function (require, module, exports) {
        (function (Buffer) {
            // Copyright Joyent, Inc. and other Node contributors.
            //
            // Permission is hereby granted, free of charge, to any person obtaining a
            // copy of this software and associated documentation files (the
            // "Software"), to deal in the Software without restriction, including
            // without limitation the rights to use, copy, modify, merge, publish,
            // distribute, sublicense, and/or sell copies of the Software, and to permit
            // persons to whom the Software is furnished to do so, subject to the
            // following conditions:
            //
            // The above copyright notice and this permission notice shall be included
            // in all copies or substantial portions of the Software.
            //
            // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
            // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
            // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
            // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
            // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
            // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
            // USE OR OTHER DEALINGS IN THE SOFTWARE.

            // NOTE: These type checking functions intentionally don't use `instanceof`
            // because it is fragile and can be easily faked with `Object.create()`.
            function isArray(ar) {
                return Array.isArray(ar);
            }
            exports.isArray = isArray;

            function isBoolean(arg) {
                return typeof arg === 'boolean';
            }
            exports.isBoolean = isBoolean;

            function isNull(arg) {
                return arg === null;
            }
            exports.isNull = isNull;

            function isNullOrUndefined(arg) {
                return arg == null;
            }
            exports.isNullOrUndefined = isNullOrUndefined;

            function isNumber(arg) {
                return typeof arg === 'number';
            }
            exports.isNumber = isNumber;

            function isString(arg) {
                return typeof arg === 'string';
            }
            exports.isString = isString;

            function isSymbol(arg) {
                return typeof arg === 'symbol';
            }
            exports.isSymbol = isSymbol;

            function isUndefined(arg) {
                return arg === void 0;
            }
            exports.isUndefined = isUndefined;

            function isRegExp(re) {
                return isObject(re) && objectToString(re) === '[object RegExp]';
            }
            exports.isRegExp = isRegExp;

            function isObject(arg) {
                return typeof arg === 'object' && arg !== null;
            }
            exports.isObject = isObject;

            function isDate(d) {
                return isObject(d) && objectToString(d) === '[object Date]';
            }
            exports.isDate = isDate;

            function isError(e) {
                return isObject(e) &&
                    (objectToString(e) === '[object Error]' || e instanceof Error);
            }
            exports.isError = isError;

            function isFunction(arg) {
                return typeof arg === 'function';
            }
            exports.isFunction = isFunction;

            function isPrimitive(arg) {
                return arg === null ||
                       typeof arg === 'boolean' ||
                       typeof arg === 'number' ||
                       typeof arg === 'string' ||
                       typeof arg === 'symbol' ||  // ES6 symbol
                       typeof arg === 'undefined';
            }
            exports.isPrimitive = isPrimitive;

            function isBuffer(arg) {
                return Buffer.isBuffer(arg);
            }
            exports.isBuffer = isBuffer;

            function objectToString(o) {
                return Object.prototype.toString.call(o);
            }
        }).call(this, require("buffer").Buffer)
    }, { "buffer": 8 }], 22: [function (require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.

        var Buffer = require('buffer').Buffer;

        var isBufferEncoding = Buffer.isEncoding
          || function (encoding) {
              switch (encoding && encoding.toLowerCase()) {
                  case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
                  default: return false;
              }
          }


        function assertEncoding(encoding) {
            if (encoding && !isBufferEncoding(encoding)) {
                throw new Error('Unknown encoding: ' + encoding);
            }
        }

        // StringDecoder provides an interface for efficiently splitting a series of
        // buffers into a series of JS strings without breaking apart multi-byte
        // characters. CESU-8 is handled as part of the UTF-8 encoding.
        //
        // @TODO Handling all encodings inside a single object makes it very difficult
        // to reason about this code, so it should be split up in the future.
        // @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
        // points as used by CESU-8.
        var StringDecoder = exports.StringDecoder = function (encoding) {
            this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
            assertEncoding(encoding);
            switch (this.encoding) {
                case 'utf8':
                    // CESU-8 represents each of Surrogate Pair by 3-bytes
                    this.surrogateSize = 3;
                    break;
                case 'ucs2':
                case 'utf16le':
                    // UTF-16 represents each of Surrogate Pair by 2-bytes
                    this.surrogateSize = 2;
                    this.detectIncompleteChar = utf16DetectIncompleteChar;
                    break;
                case 'base64':
                    // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
                    this.surrogateSize = 3;
                    this.detectIncompleteChar = base64DetectIncompleteChar;
                    break;
                default:
                    this.write = passThroughWrite;
                    return;
            }

            // Enough space to store all bytes of a single character. UTF-8 needs 4
            // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
            this.charBuffer = new Buffer(6);
            // Number of bytes received for the current incomplete multi-byte character.
            this.charReceived = 0;
            // Number of bytes expected for the current incomplete multi-byte character.
            this.charLength = 0;
        };


        // write decodes the given buffer and returns it as JS string that is
        // guaranteed to not contain any partial multi-byte characters. Any partial
        // character found at the end of the buffer is buffered up, and will be
        // returned when calling write again with the remaining bytes.
        //
        // Note: Converting a Buffer containing an orphan surrogate to a String
        // currently works, but converting a String to a Buffer (via `new Buffer`, or
        // Buffer#write) will replace incomplete surrogates with the unicode
        // replacement character. See https://codereview.chromium.org/121173009/ .
        StringDecoder.prototype.write = function (buffer) {
            var charStr = '';
            // if our last write ended with an incomplete multibyte character
            while (this.charLength) {
                // determine how many remaining bytes this buffer has to offer for this char
                var available = (buffer.length >= this.charLength - this.charReceived) ?
                    this.charLength - this.charReceived :
                    buffer.length;

                // add the new bytes to the char buffer
                buffer.copy(this.charBuffer, this.charReceived, 0, available);
                this.charReceived += available;

                if (this.charReceived < this.charLength) {
                    // still not enough chars in this buffer? wait for more ...
                    return '';
                }

                // remove bytes belonging to the current character from the buffer
                buffer = buffer.slice(available, buffer.length);

                // get the character that was split
                charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

                // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
                var charCode = charStr.charCodeAt(charStr.length - 1);
                if (charCode >= 0xD800 && charCode <= 0xDBFF) {
                    this.charLength += this.surrogateSize;
                    charStr = '';
                    continue;
                }
                this.charReceived = this.charLength = 0;

                // if there are no more bytes in this buffer, just emit our char
                if (buffer.length === 0) {
                    return charStr;
                }
                break;
            }

            // determine and set charLength / charReceived
            this.detectIncompleteChar(buffer);

            var end = buffer.length;
            if (this.charLength) {
                // buffer the incomplete character bytes we got
                buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
                end -= this.charReceived;
            }

            charStr += buffer.toString(this.encoding, 0, end);

            var end = charStr.length - 1;
            var charCode = charStr.charCodeAt(end);
            // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
            if (charCode >= 0xD800 && charCode <= 0xDBFF) {
                var size = this.surrogateSize;
                this.charLength += size;
                this.charReceived += size;
                this.charBuffer.copy(this.charBuffer, size, 0, size);
                buffer.copy(this.charBuffer, 0, 0, size);
                return charStr.substring(0, end);
            }

            // or just emit the charStr
            return charStr;
        };

        // detectIncompleteChar determines if there is an incomplete UTF-8 character at
        // the end of the given buffer. If so, it sets this.charLength to the byte
        // length that character, and sets this.charReceived to the number of bytes
        // that are available for this character.
        StringDecoder.prototype.detectIncompleteChar = function (buffer) {
            // determine how many bytes we have to check at the end of this buffer
            var i = (buffer.length >= 3) ? 3 : buffer.length;

            // Figure out if one of the last i bytes of our buffer announces an
            // incomplete char.
            for (; i > 0; i--) {
                var c = buffer[buffer.length - i];

                // See http://en.wikipedia.org/wiki/UTF-8#Description

                // 110XXXXX
                if (i == 1 && c >> 5 == 0x06) {
                    this.charLength = 2;
                    break;
                }

                // 1110XXXX
                if (i <= 2 && c >> 4 == 0x0E) {
                    this.charLength = 3;
                    break;
                }

                // 11110XXX
                if (i <= 3 && c >> 3 == 0x1E) {
                    this.charLength = 4;
                    break;
                }
            }
            this.charReceived = i;
        };

        StringDecoder.prototype.end = function (buffer) {
            var res = '';
            if (buffer && buffer.length)
                res = this.write(buffer);

            if (this.charReceived) {
                var cr = this.charReceived;
                var buf = this.charBuffer;
                var enc = this.encoding;
                res += buf.slice(0, cr).toString(enc);
            }

            return res;
        };

        function passThroughWrite(buffer) {
            return buffer.toString(this.encoding);
        }

        function utf16DetectIncompleteChar(buffer) {
            this.charReceived = buffer.length % 2;
            this.charLength = this.charReceived ? 2 : 0;
        }

        function base64DetectIncompleteChar(buffer) {
            this.charReceived = buffer.length % 3;
            this.charLength = this.charReceived ? 3 : 0;
        }

    }, { "buffer": 8 }], 23: [function (require, module, exports) {
        module.exports = require("./lib/_stream_passthrough.js")

    }, { "./lib/_stream_passthrough.js": 17 }], 24: [function (require, module, exports) {
        exports = module.exports = require('./lib/_stream_readable.js');
        exports.Readable = exports;
        exports.Writable = require('./lib/_stream_writable.js');
        exports.Duplex = require('./lib/_stream_duplex.js');
        exports.Transform = require('./lib/_stream_transform.js');
        exports.PassThrough = require('./lib/_stream_passthrough.js');

    }, { "./lib/_stream_duplex.js": 16, "./lib/_stream_passthrough.js": 17, "./lib/_stream_readable.js": 18, "./lib/_stream_transform.js": 19, "./lib/_stream_writable.js": 20 }], 25: [function (require, module, exports) {
        module.exports = require("./lib/_stream_transform.js")

    }, { "./lib/_stream_transform.js": 19 }], 26: [function (require, module, exports) {
        module.exports = require("./lib/_stream_writable.js")

    }, { "./lib/_stream_writable.js": 20 }], 27: [function (require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.

        module.exports = Stream;

        var EE = require('events').EventEmitter;
        var inherits = require('inherits');

        inherits(Stream, EE);
        Stream.Readable = require('readable-stream/readable.js');
        Stream.Writable = require('readable-stream/writable.js');
        Stream.Duplex = require('readable-stream/duplex.js');
        Stream.Transform = require('readable-stream/transform.js');
        Stream.PassThrough = require('readable-stream/passthrough.js');

        // Backwards-compat with node 0.4.x
        Stream.Stream = Stream;



        // old-style streams.  Note that the pipe method (the only relevant
        // part of this class) is overridden in the Readable class.

        function Stream() {
            EE.call(this);
        }

        Stream.prototype.pipe = function (dest, options) {
            var source = this;

            function ondata(chunk) {
                if (dest.writable) {
                    if (false === dest.write(chunk) && source.pause) {
                        source.pause();
                    }
                }
            }

            source.on('data', ondata);

            function ondrain() {
                if (source.readable && source.resume) {
                    source.resume();
                }
            }

            dest.on('drain', ondrain);

            // If the 'end' option is not supplied, dest.end() will be called when
            // source gets the 'end' or 'close' events.  Only dest.end() once.
            if (!dest._isStdio && (!options || options.end !== false)) {
                source.on('end', onend);
                source.on('close', onclose);
            }

            var didOnEnd = false;
            function onend() {
                if (didOnEnd) return;
                didOnEnd = true;

                dest.end();
            }


            function onclose() {
                if (didOnEnd) return;
                didOnEnd = true;

                if (typeof dest.destroy === 'function') dest.destroy();
            }

            // don't leave dangling pipes when there are errors.
            function onerror(er) {
                cleanup();
                if (EE.listenerCount(this, 'error') === 0) {
                    throw er; // Unhandled stream error in pipe.
                }
            }

            source.on('error', onerror);
            dest.on('error', onerror);

            // remove all the event listeners that were added.
            function cleanup() {
                source.removeListener('data', ondata);
                dest.removeListener('drain', ondrain);

                source.removeListener('end', onend);
                source.removeListener('close', onclose);

                source.removeListener('error', onerror);
                dest.removeListener('error', onerror);

                source.removeListener('end', cleanup);
                source.removeListener('close', cleanup);

                dest.removeListener('close', cleanup);
            }

            source.on('end', cleanup);
            source.on('close', cleanup);

            dest.on('close', cleanup);

            dest.emit('pipe', source);

            // Allow for unix-like usage: A.pipe(B).pipe(C)
            return dest;
        };

    }, { "events": 11, "inherits": 12, "readable-stream/duplex.js": 15, "readable-stream/passthrough.js": 23, "readable-stream/readable.js": 24, "readable-stream/transform.js": 25, "readable-stream/writable.js": 26 }]
}, {}, [1]);
